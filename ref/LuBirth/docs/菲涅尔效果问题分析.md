# LuBirth项目菲涅尔效果问题分析

## 当前实现概述

### 云层系统架构

#### 1. 基础云层实现
- **几何体**: 球面表面云层，使用多层球壳叠加
- **材质**: 自定义GLSL着色器材质
- **层数**: 支持动态层数（默认3层，放大时16层）
- **层间距**: 0.002单位，放大时减少到0.0015
- **采样**: 传统UV采样 + Triplanar采样选项

#### 2. 多层叠加系统
```typescript
// 云层组件结构
CloudsWithLayers -> Clouds[0..n] -> 球面几何体
```

**叠加策略**:
- **全景模式**: 3层，层间距0.002
- **放大模式**: 16层，层间距0.0015，减少视觉分离
- **Z轴叠加**: 真正的径向叠加，避免XY平面位移
- **同步滚动**: 所有层使用相同的UV滚动速度

#### 3. 体积散射系统
```glsl
// 体积密度采样
float sampleVolumeDensity(vec2 uv, float depth) {
    float density = 1.0 - smoothstep(0.0, 0.8, depth);
    // 添加蓝噪声变化
    float noise = blueNoise(uv * noiseScale);
    density *= (0.6 + noiseStrength * noise);
    return density * volumeDensity;
}
```

**散射计算**:
- Henyey-Greenstein相位函数
- 密度增强倍数控制
- 边缘增强效果
- 可配置散射颜色

### 相机控制系统

#### 1. 相机参数结构
```typescript
interface CameraControls {
  cameraDistance: number;      // 相机距离 (默认15)
  cameraAzimuthDeg: number;   // 方位角 λ
  cameraElevationDeg: number; // 仰角 φ
  lookAtDistanceRatio: number; // 朝向倍率 (0=地心)
  viewOffsetY: number;        // 视口纵向偏移
}
```

#### 2. 放大模式实现
```typescript
// 出生点对齐放大
const earthSize = 1.68;        // 地球放大倍数
const cameraDistance = 15;     // 相机距离
const pitch = -(targetLat - obsLat); // 俯仰角计算
const lookAtDistanceRatio = 1.08;    // 朝向倍率
```

**关键参数**:
- 地球大小: 0.33 → 1.68 (5倍放大)
- 相机距离: 保持15单位
- 云层: 3层 → 16层体积渲染
- 层间距: 0.002 → 0.0015

#### 3. 视角变换
- **方位角**: 基于出生点经度计算
- **俯仰角**: 基于目标纬度与观察纬度差值
- **地球位置**: 出现在画面下方1/3处

### 当前菲涅尔实现问题

#### 1. 实现位置
文件: `/Users/zuobowen/Documents/GitHub/LuBirth/src/scenes/simple/api/components/Clouds.tsx`

#### 2. 当前算法
```glsl
// 当前实现（简化版）
vec3 N = normalize(vPosition);              // 表面法线
vec3 V = normalize(-vViewPosition);         // 视向量
float NV = clamp(dot(N, V), 0.0, 1.0);     // 夹角余弦
float rim = pow(1.0 - NV, fresnelPower);     // 菲涅尔边缘
```

#### 3. 参数控制
```typescript
// 菲涅尔参数
cloudUseFresnel: true,           // 启用菲涅尔
cloudFresnelPower: 2.0,         // 幂次 (2.0)
cloudFresnelStrength: 0.7,      // 强度 (0.7)
```

## 问题根源分析

### 1. 理论与实际的差距

#### 文档建议的完整实现
```glsl
// 文档中的理想实现
vec3 P = vPosition;                    // 片元世界坐标
vec3 C = cameraPosition;                // 相机世界坐标
vec3 O = sphereCenter;                 // 球心
vec3 N = normalize(P - O);             // 表面法线
vec3 V = normalize(P - C);             // 视向量
float NV = clamp(dot(N, V), 0.0, 1.0); // 法线与视线夹角
float rim = pow(1.0 - NV, rimPower);   // 菲涅尔边缘
```

#### 当前实现的限制
- **相机位置获取**: 使用 `vViewPosition` 代替真实相机位置
- **球心坐标**: 假设为原点，但实际可能有偏移
- **坐标系**: 世界坐标系与视图坐标系的转换问题

### 2. 多层叠加的复杂性

#### 视觉影响
- 16层云层叠加产生复杂的深度效果
- 每层的法线计算可能存在微小差异
- 层间透明度混合影响菲涅尔效果

#### 性能考虑
- 16层同时计算菲涅尔增加GPU负担
- 需要平衡效果与性能

### 3. 相机俯仰角的挑战

#### 放大模式特点
- 相机有显著俯仰角 (约3.2°)
- 地球只占画面下部1/3
- 云层只有部分进入视野

#### 菲涅尔效果要求
- 需要针对可见部分计算边缘透明
- 中心与边缘的界定在斜视角下变得复杂
- 传统球面边缘计算不再适用

## 技术细节分析

### 1. 坐标系统
- **世界坐标系**: Three.js标准右手坐标系
- **视图坐标系**: 相机相关的局部坐标系
- **球面坐标系**: 地理坐标系的映射

### 2. 着色器变量
```glsl
// 当前可用的变量
varying vec3 vPosition;        // 世界坐标
varying vec3 vViewPosition;    // 视图坐标
varying vec3 vNormalW;         // 世界法线
```

### 3. 计算流程
1. **顶点着色器**: 计算位置、法线、视图坐标
2. **片段着色器**: 对每个像素进行菲涅尔计算
3. **透明度混合**: 将菲涅尔效果应用到最终alpha

## 优化方向

### 1. 精确的相机位置获取
需要获取真实的相机世界坐标，而不是依赖视图坐标。

### 2. 视锥体裁剪优化
考虑实现文档中提到的视锥体-球体相交计算，确定可见区域。

### 3. 多层菲涅尔一致性
确保所有云层的菲涅尔计算保持一致，避免层间视觉冲突。

### 4. 动态参数调整
根据相机距离和角度动态调整菲涅尔参数。

## 结论

当前菲涅尔实现虽然在数学上是正确的，但在实际应用中由于多层叠加、相机角度、坐标系统等复杂因素，效果不够明显。需要更精确的相机位置计算和针对特定视角的优化算法。