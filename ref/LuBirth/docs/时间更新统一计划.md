# 时间更新统一计划

## 🎯 **问题背景**

用户反馈：选择时间然后更新时间后，自转的数据没有传导到黄昏点计算、光照角度这些，只是单纯自转了，使用对齐经度及对齐放大功能时都没有成功捕捉到新的自转角度。

## 🔍 **问题分析**

### **核心问题：数据流断裂**

1. **地球自转角度更新正常**：
   - `earthYawDeg` 在时间变化时能正确计算和更新
   - 实时更新、手动更新都有相应的 `updateValue('earthYawDeg', newEarthRotation)` 调用

2. **但光照计算和黄昏点计算没有使用最新的自转角度**：
   - `lightInfo` 计算（第998-1015行）只依赖 `sunWorld` 和 `sunAngles`
   - 黄昏点经度计算（第1006-1007行）直接使用 `sunWorld`，没有考虑地球自转
   - `updateSunlight` 函数（第737行）计算太阳位置时没有使用当前的 `earthYawDeg`

3. **对齐功能失效的原因**：
   - `AlignOnDemand` 组件（第499行）在固定太阳模式下被完全禁用
   - `alignLongitudeOnly` 函数（第58行）被注释掉（第519行）
   - 对齐放大功能（第2650行）使用固定的 `earthYaw` 值，没有获取最新的自转角度

### **具体问题点**

#### 1. 光照计算独立于地球自转
```typescript
// 第998行：lightInfo 只依赖 sunWorld 和 sunAngles
const lightInfo = React.useMemo(() => {
  const { x, y, z } = sunWorld;  // 这里没有考虑地球自转
  // ...
}, [sunWorld, sunAngles]);  // 缺少 earthYawDeg 依赖
```

#### 2. 黄昏点计算错误
```typescript
// 第1006-1007行：直接使用太阳世界坐标，没有考虑地球自转
const lightDir = new THREE.Vector3(-x, -y, -z).normalize();
let lonDusk = THREE.MathUtils.radToDeg(Math.atan2(-lightDir.x, lightDir.z));
```

#### 3. 对齐功能被禁用
```typescript
// 第512-515行：固定太阳模式下禁用自动对齐
if (useFixedSun) {
  if (logger.isEnabled()) logger.log('align/skip-fixed-sun', { tick, reason: '固定太阳模式下禁用自动yaw对齐' });
  return;
}
```

#### 4. 对齐放大使用旧的自转角度
```typescript
// 第1448行：使用 composition.earthYawDeg，可能不是最新的
let earthYaw = composition.earthYawDeg || 0;
```

## 🚀 **解决方案：禁用自动时间更新**

### **方案概述**

**核心思路**：禁用所有自动时间更新机制，改为用户手动控制时间，确保时间与自转角度完全同步。

### **当前自动更新机制的问题**

1. **实时时间更新** (`realTimeUpdate`)：
   ```typescript
   // 第887-931行：每分钟更新一次时间
   const interval = setInterval(() => {
     const now = new Date();
     const newTime = toLocalInputValue(now);
     setDateISO(newTime);
     // 同时更新地球自转角度
     const earthRotation = (hoursFloat * 15) % 360;
     updateValue('earthYawDeg', earthRotation);
   }, 60000);
   ```

2. **平滑自转更新**：
   ```typescript
   // 第939-958行：每250ms平滑更新自转角度
   const timer = setInterval(() => {
     const yaw = (hoursFloat * 15) % 360;
     updateValue('earthYawDeg', yaw);
   }, 250);
   ```

### **禁用自动更新的优势**

✅ **解决核心问题**：
- 消除时间与自转角度不同步的问题
- 用户手动设置时间后，系统状态保持稳定
- 避免自动更新覆盖用户设置

✅ **用户体验改善**：
- 用户有完全的时间控制权
- 不会出现"设置时间后又被自动更新覆盖"的困扰
- 对齐功能可以基于用户设定的时间稳定工作

✅ **简化逻辑**：
- 减少多个定时器的复杂性
- 避免 `userModifiedTimeRef` 等复杂的状态管理
- 数据流更清晰：用户操作 → 时间更新 → 自转角度更新

### **潜在影响和考虑**

⚠️ **需要考虑的点**：

1. **初始化时机**：
   ```typescript
   // 需要确保首次加载时获取当前时间
   const [dateISO, setDateISO] = useState(() => getCurrentLocalTime());
   ```

2. **手动更新触发**：
   ```typescript
   // 用户修改时间时需要同时更新自转角度
   const handleTimeChange = (newTime: string) => {
     setDateISO(newTime);
     const newEarthRotation = calculateEarthRotationFromDateISO(newTime, lonDeg);
     updateValue('earthYawDeg', newEarthRotation);
   };
   ```

3. **重置功能保留**：
   ```typescript
   // 保留"重置为当前时间"功能
   const handleResetToCurrentTime = () => {
     const currentTime = getCurrentLocalTime();
     setDateISO(currentTime);
     const newEarthRotation = calculateEarthRotationFromDateISO(currentTime, lonDeg);
     updateValue('earthYawDeg', newEarthRotation);
   };
   ```

## 🔧 **实现方案**

### **1. 默认禁用自动更新**

```typescript
// 修改默认值
const [realTimeUpdate, setRealTimeUpdate] = useState(false); // 默认 false
const [autoUpdate, setAutoUpdate] = useState(false); // 默认 false
```

### **2. 时间变化时同步更新自转角度**

```typescript
// 统一的时间更新处理函数
const handleTimeChange = (newTime: string) => {
  setDateISO(newTime);
  // 立即计算并更新自转角度
  const bLon = composition.birthPointLongitudeDeg || lonDeg;
  const newEarthRotation = calculateEarthRotationFromDateISO(newTime, bLon);
  updateValue('earthYawDeg', newEarthRotation);
  // 触发光照更新
  updateSunlight();
};
```

### **3. 移除所有自动更新定时器**

```typescript
// 删除以下 useEffect：
// - realTimeUpdate 相关的 useEffect (第887-931行)
// - 平滑自转的定时器 (第939-958行)
// - userModifiedTimeRef 相关逻辑
```

### **4. 修复光照计算依赖**

```typescript
// 修改 lightInfo 计算，添加 earthYawDeg 依赖
const lightInfo = React.useMemo(() => {
  const { x, y, z } = sunWorld;
  const { azDeg, altDeg } = sunAngles;
  
  // 考虑地球自转的黄昏点计算
  const earthYawRad = THREE.MathUtils.degToRad(composition.earthYawDeg || 0);
  const rotatedSunWorld = new THREE.Vector3(x, y, z).applyAxisAngle(
    new THREE.Vector3(0, 1, 0), earthYawRad
  );
  
  // 计算黄昏点经度：考虑地球自转
  const lightDir = new THREE.Vector3(-rotatedSunWorld.x, -rotatedSunWorld.y, -rotatedSunWorld.z).normalize();
  let lonDusk = THREE.MathUtils.radToDeg(Math.atan2(-lightDir.x, lightDir.z));
  
  return {
    azimuth: azDeg.toFixed(1),
    elevation: altDeg.toFixed(1),
    intensity: Math.sqrt(x*x + y*y + z*z).toFixed(3),
    duskLongitude: lonDusk.toFixed(1)
  };
}, [sunWorld, sunAngles, composition.earthYawDeg]); // 添加 earthYawDeg 依赖
```

### **5. 修复对齐功能**

```typescript
// 恢复 alignLongitudeOnly 功能
function AlignOnDemand({ tick, latDeg, lonDeg, sunWorld, useFixedSun, fixedSunDir, birthPointMode }: { tick: number; latDeg: number; lonDeg: number; sunWorld: {x:number;y:number;z:number}; useFixedSun?: boolean; fixedSunDir?: [number,number,number]; birthPointMode?: boolean }) {
  const { scene, camera } = useThree();
  React.useEffect(() => {
    try {
      if (birthPointMode) {
        if (logger.isEnabled()) logger.log('align/skip-birth-point-mode', { tick, reason: '出生点对齐模式激活，跳过地球旋转' });
        return;
      }
      
      const earth = scene.getObjectByName('earthRoot');
      if (earth) {
        // 移除固定太阳模式下的禁用逻辑
        if (logger.isEnabled()) logger.log('align/trigger', { tick, lonDeg, useFixedSun: !!useFixedSun });
        // 恢复 alignLongitudeOnly 调用
        alignLongitudeOnly(earth as THREE.Object3D, camera, lonDeg);
      } else {
        if (logger.isEnabled()) logger.warn('align/earthRoot-missing');
      }
    } catch (err) {
      if (logger.isEnabled()) logger.error('align/fail', String(err));
    }
  }, [tick, useFixedSun, lonDeg]);
  return null;
}
```

### **6. 修复对齐放大功能**

```typescript
// 在对齐放大功能中获取最新的自转角度
<button className="btn" onClick={() => {
  try {
    // 获取最新的自转角度，而不是使用可能过时的 composition.earthYawDeg
    const currentEarthYaw = composition.earthYawDeg || 0;
    const seam = composition.seamOffsetDeg ?? 0;
    const L0 = lonDeg || 0;
    let L = L0; while (L > 180) L -= 360; while (L < -180) L += 360;
    
    // 使用最新的自转角度进行对齐计算
    // ... 对齐逻辑
  } catch (e) {
    console.error('[AlignZoom] failed:', e);
  }
}}>对齐放大</button>
```

## 📋 **实施步骤**

### **阶段1：禁用自动更新**
1. 修改 `realTimeUpdate` 和 `autoUpdate` 默认值为 `false`
2. 移除所有自动更新相关的 `useEffect`
3. 移除 `userModifiedTimeRef` 相关逻辑

### **阶段2：修复数据流**
1. 修改 `lightInfo` 计算，添加 `earthYawDeg` 依赖
2. 修复黄昏点计算，考虑地球自转
3. 确保时间变化时同步更新自转角度

### **阶段3：恢复对齐功能**
1. 恢复 `alignLongitudeOnly` 调用
2. 移除固定太阳模式下的对齐禁用逻辑
3. 修复对齐放大功能中的自转角度获取

### **阶段4：测试验证**
1. 测试时间修改后自转角度是否正确更新
2. 测试黄昏点计算是否反映地球自转
3. 测试对齐功能是否能正确捕捉自转角度
4. 测试光照角度显示是否准确

## 🎯 **预期效果**

### **修复前**
- 时间更新后，地球自转但黄昏线位置不变
- 光照角度显示不准确
- 对齐功能无法捕捉新的自转角度
- 用户体验：设置时间后"只是单纯自转了"

### **修复后**
- 时间更新后，所有相关计算都基于新的自转角度
- 黄昏线位置正确反映地球自转
- 光照角度显示准确
- 对齐功能能正确捕捉自转角度
- 用户体验：完全控制时间，系统状态稳定一致

## 🔄 **与现有功能的兼容性**

✅ **对齐功能**：
- 用户设置时间后，自转角度固定
- 对齐经度、对齐放大功能可以稳定工作
- 不会因为自动更新而重新对齐

✅ **黄昏点计算**：
- 基于用户设定的时间计算
- 结果稳定，不会自动变化

✅ **光照角度**：
- 基于用户设定的时间计算
- 显示结果一致

✅ **固定太阳模式**：
- 保持现有功能不变
- 只是禁用自动更新，不影响固定太阳逻辑

## 📝 **总结**

这个方案**非常可行**，能从根本上解决当前的问题：

1. **解决核心问题**：消除时间与自转角度不同步
2. **改善用户体验**：用户有完全控制权
3. **简化系统逻辑**：减少复杂的自动更新机制
4. **保持功能完整**：所有现有功能都能正常工作

通过禁用自动时间更新，改为用户手动控制，可以确保时间、自转角度、光照计算、黄昏点计算、对齐功能等所有相关系统保持完全同步，从根本上解决数据传导问题。
