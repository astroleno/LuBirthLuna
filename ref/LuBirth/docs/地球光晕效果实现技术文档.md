# 地球光晕效果实现技术文档

## 📋 概述

本文档详细介绍如何在LuBirth项目中实现地球光晕（大气散射）效果，该效果从地球表面扩散到空中，并根据光照面动态调整强度，营造真实的大气层视觉效果。

## 🎯 效果目标

- **视觉效果**：地球边缘出现柔和的蓝色光晕
- **物理准确性**：光照面光晕更强，背光面光晕较弱
- **动态变化**：随地球自转和太阳位置实时调整
- **性能优化**：保持60fps流畅渲染

## 🔬 技术原理

### 大气散射物理学

```
太阳光 → 大气层 → 瑞利散射 → 蓝色光晕
         ↓
      米氏散射 → 白色/橙色边缘
```

**瑞利散射**：短波长（蓝光）散射更强烈
**米氏散射**：较大粒子散射，产生白色光晕
**吸收效应**：大气层厚度影响光晕强度

### 实现策略

1. **几何方法**：使用略大于地球的球体作为大气层
2. **着色器技术**：基于视角和光照方向计算散射强度
3. **混合模式**：使用加法混合实现发光效果
4. **LOD优化**：距离自适应质量调整

## 🛠️ 实现方案

### 方案一：基础球体光晕（推荐入门）

**优点**：实现简单，性能良好
**缺点**：物理准确性一般

```typescript
// src/scenes/simple/components/EarthAtmosphere.tsx
import React from 'react';
import * as THREE from 'three';
import { useFrame } from '@react-three/fiber';

interface EarthAtmosphereProps {
  earthRadius: number;
  lightDirection: THREE.Vector3;
  intensity?: number;
  color?: THREE.Color;
}

export function EarthAtmosphere({ 
  earthRadius, 
  lightDirection, 
  intensity = 1.0,
  color = new THREE.Color(0x87CEEB) // 天蓝色
}: EarthAtmosphereProps) {
  const atmosphereRef = React.useRef<THREE.Mesh>(null);
  
  // 大气层材质
  const atmosphereMaterial = React.useMemo(() => {
    return new THREE.ShaderMaterial({
      uniforms: {
        u_lightDirection: { value: lightDirection },
        u_intensity: { value: intensity },
        u_color: { value: color },
        u_time: { value: 0 }
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vPosition = position;
          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 u_lightDirection;
        uniform float u_intensity;
        uniform vec3 u_color;
        
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        
        void main() {
          // 计算视角方向
          vec3 viewDirection = normalize(cameraPosition - vWorldPosition);
          
          // 边缘检测（菲涅尔效应）
          float fresnel = 1.0 - abs(dot(viewDirection, vNormal));
          fresnel = pow(fresnel, 2.0);
          
          // 光照影响
          float lightInfluence = max(0.0, dot(vNormal, -u_lightDirection));
          lightInfluence = 0.3 + 0.7 * lightInfluence; // 保持最小亮度
          
          // 最终颜色
          vec3 finalColor = u_color * u_intensity * lightInfluence;
          float alpha = fresnel * 0.6; // 透明度
          
          gl_FragColor = vec4(finalColor, alpha);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide, // 从内部渲染
      depthWrite: false
    });
  }, [lightDirection, intensity, color]);
  
  // 实时更新光照方向
  useFrame(() => {
    if (atmosphereMaterial.uniforms) {
      atmosphereMaterial.uniforms.u_lightDirection.value.copy(lightDirection);
    }
  });
  
  return (
    <mesh ref={atmosphereRef} material={atmosphereMaterial}>
      <sphereGeometry args={[earthRadius * 1.05, 64, 32]} />
    </mesh>
  );
}
```

### 方案二：物理准确的大气散射

**优点**：高度真实，视觉效果卓越
**缺点**：计算复杂，性能要求高

```typescript
// src/scenes/simple/components/PhysicalAtmosphere.tsx
import React from 'react';
import * as THREE from 'three';
import { useFrame } from '@react-three/fiber';

interface PhysicalAtmosphereProps {
  earthRadius: number;
  atmosphereHeight: number;
  lightDirection: THREE.Vector3;
  sunIntensity?: number;
}

export function PhysicalAtmosphere({ 
  earthRadius, 
  atmosphereHeight = earthRadius * 0.05,
  lightDirection,
  sunIntensity = 1.0
}: PhysicalAtmosphereProps) {
  const atmosphereRef = React.useRef<THREE.Mesh>(null);
  
  const atmosphereMaterial = React.useMemo(() => {
    return new THREE.ShaderMaterial({
      uniforms: {
        u_earthRadius: { value: earthRadius },
        u_atmosphereRadius: { value: earthRadius + atmosphereHeight },
        u_lightDirection: { value: lightDirection },
        u_sunIntensity: { value: sunIntensity },
        
        // 物理常数
        u_rayleighCoefficient: { value: new THREE.Vector3(0.0025, 0.0104, 0.0231) },
        u_mieCoefficient: { value: 0.005 },
        u_rayleighScaleHeight: { value: 8000.0 },
        u_mieScaleHeight: { value: 1200.0 },
        u_mieG: { value: 0.8 } // 米氏散射不对称参数
      },
      vertexShader: `
        varying vec3 vWorldPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        
        void main() {
          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
          vNormal = normalize(normalMatrix * normal);
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float u_earthRadius;
        uniform float u_atmosphereRadius;
        uniform vec3 u_lightDirection;
        uniform float u_sunIntensity;
        
        // 散射参数
        uniform vec3 u_rayleighCoefficient;
        uniform float u_mieCoefficient;
        uniform float u_rayleighScaleHeight;
        uniform float u_mieScaleHeight;
        uniform float u_mieG;
        
        varying vec3 vWorldPosition;
        varying vec3 vNormal;
        
        // 计算光线与球面的交点
        vec2 raySphereIntersect(vec3 rayOrigin, vec3 rayDir, float sphereRadius) {
          float a = dot(rayDir, rayDir);
          float b = 2.0 * dot(rayOrigin, rayDir);
          float c = dot(rayOrigin, rayOrigin) - sphereRadius * sphereRadius;
          float discriminant = b * b - 4.0 * a * c;
          
          if (discriminant < 0.0) return vec2(-1.0);
          
          float sqrt_d = sqrt(discriminant);
          return vec2((-b - sqrt_d) / (2.0 * a), (-b + sqrt_d) / (2.0 * a));
        }
        
        // 瑞利散射相函数
        float rayleighPhase(float cosTheta) {
          return 3.0 / (16.0 * 3.14159265) * (1.0 + cosTheta * cosTheta);
        }
        
        // 米氏散射相函数
        float miePhase(float cosTheta, float g) {
          float g2 = g * g;
          float numerator = 3.0 * (1.0 - g2) * (1.0 + cosTheta * cosTheta);
          float denominator = 8.0 * 3.14159265 * (2.0 + g2) * pow(1.0 + g2 - 2.0 * g * cosTheta, 1.5);
          return numerator / denominator;
        }
        
        // 计算大气密度
        float atmosphereDensity(float height, float scaleHeight) {
          return exp(-height / scaleHeight);
        }
        
        // 主要散射计算
        vec3 calculateScattering(vec3 rayStart, vec3 rayDir, float rayLength) {
          const int SAMPLE_COUNT = 16;
          float stepSize = rayLength / float(SAMPLE_COUNT);
          
          vec3 rayleighScattering = vec3(0.0);
          vec3 mieScattering = vec3(0.0);
          
          for (int i = 0; i < SAMPLE_COUNT; i++) {
            vec3 samplePos = rayStart + rayDir * (float(i) + 0.5) * stepSize;
            float height = length(samplePos) - u_earthRadius;
            
            // 计算密度
            float rayleighDensity = atmosphereDensity(height, u_rayleighScaleHeight);
            float mieDensity = atmosphereDensity(height, u_mieScaleHeight);
            
            // 累积散射
            rayleighScattering += u_rayleighCoefficient * rayleighDensity * stepSize;
            mieScattering += vec3(u_mieCoefficient) * mieDensity * stepSize;
          }
          
          // 计算相函数
          float cosTheta = dot(rayDir, -u_lightDirection);
          float rayleighPhaseValue = rayleighPhase(cosTheta);
          float miePhaseValue = miePhase(cosTheta, u_mieG);
          
          // 最终散射颜色
          vec3 finalColor = rayleighScattering * rayleighPhaseValue + 
                           mieScattering * miePhaseValue;
          
          return finalColor * u_sunIntensity;
        }
        
        void main() {
          vec3 rayOrigin = cameraPosition;
          vec3 rayDir = normalize(vWorldPosition - cameraPosition);
          
          // 计算与大气层的交点
          vec2 atmosphereIntersect = raySphereIntersect(rayOrigin, rayDir, u_atmosphereRadius);
          vec2 earthIntersect = raySphereIntersect(rayOrigin, rayDir, u_earthRadius);
          
          if (atmosphereIntersect.x < 0.0) {
            discard; // 光线未击中大气层
          }
          
          float rayStart = max(0.0, atmosphereIntersect.x);
          float rayEnd = atmosphereIntersect.y;
          
          // 如果光线击中地球，则截断到地球表面
          if (earthIntersect.x > 0.0) {
            rayEnd = min(rayEnd, earthIntersect.x);
          }
          
          float rayLength = rayEnd - rayStart;
          vec3 scattering = calculateScattering(
            rayOrigin + rayDir * rayStart, 
            rayDir, 
            rayLength
          );
          
          // 应用曝光和色调映射
          scattering = 1.0 - exp(-scattering * 2.0);
          
          gl_FragColor = vec4(scattering, 1.0);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide,
      depthWrite: false
    });
  }, [earthRadius, atmosphereHeight, lightDirection, sunIntensity]);
  
  useFrame(() => {
    if (atmosphereMaterial.uniforms) {
      atmosphereMaterial.uniforms.u_lightDirection.value.copy(lightDirection);
    }
  });
  
  return (
    <mesh ref={atmosphereRef} material={atmosphereMaterial}>
      <sphereGeometry args={[earthRadius + atmosphereHeight, 64, 32]} />
    </mesh>
  );
}
```

### 方案三：分层大气效果

**优点**：性能与效果平衡，可配置性强
**缺点**：实现复杂度中等

```typescript
// src/scenes/simple/components/LayeredAtmosphere.tsx
import React from 'react';
import * as THREE from 'three';

interface LayeredAtmosphereProps {
  earthRadius: number;
  lightDirection: THREE.Vector3;
  layers?: AtmosphereLayer[];
}

interface AtmosphereLayer {
  height: number;        // 相对于地球表面的高度
  color: THREE.Color;    // 层的颜色
  intensity: number;     // 强度
  scattering: number;    // 散射强度
}

export function LayeredAtmosphere({ 
  earthRadius, 
  lightDirection,
  layers = [
    { height: 0.02, color: new THREE.Color(0x87CEEB), intensity: 0.8, scattering: 1.5 },
    { height: 0.04, color: new THREE.Color(0x4169E1), intensity: 0.4, scattering: 1.0 },
    { height: 0.06, color: new THREE.Color(0x191970), intensity: 0.2, scattering: 0.5 }
  ]
}: LayeredAtmosphereProps) {
  
  return (
    <>
      {layers.map((layer, index) => (
        <mesh key={index}>
          <sphereGeometry args={[earthRadius * (1 + layer.height), 64, 32]} />
          <shaderMaterial
            uniforms={{
              u_lightDirection: { value: lightDirection },
              u_color: { value: layer.color },
              u_intensity: { value: layer.intensity },
              u_scattering: { value: layer.scattering }
            }}
            vertexShader={`
              varying vec3 vNormal;
              varying vec3 vWorldPosition;
              
              void main() {
                vNormal = normalize(normalMatrix * normal);
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `}
            fragmentShader={`
              uniform vec3 u_lightDirection;
              uniform vec3 u_color;
              uniform float u_intensity;
              uniform float u_scattering;
              
              varying vec3 vNormal;
              varying vec3 vWorldPosition;
              
              void main() {
                vec3 viewDir = normalize(cameraPosition - vWorldPosition);
                
                // 边缘强度
                float fresnel = 1.0 - abs(dot(viewDir, vNormal));
                fresnel = pow(fresnel, u_scattering);
                
                // 光照影响
                float lightDot = dot(vNormal, -u_lightDirection);
                float lightInfluence = 0.2 + 0.8 * max(0.0, lightDot);
                
                vec3 finalColor = u_color * u_intensity * lightInfluence;
                float alpha = fresnel * 0.3;
                
                gl_FragColor = vec4(finalColor, alpha);
              }
            `}
            transparent
            blending={THREE.AdditiveBlending}
            side={THREE.BackSide}
            depthWrite={false}
          />
        </mesh>
      ))}
    </>
  );
}
```

## 🔧 集成到现有系统

### 1. 在Earth组件中集成

```typescript
// src/scenes/simple/api/components/Earth.tsx
import { EarthAtmosphere } from '../../../components/EarthAtmosphere';

interface EarthProps {
  // ... 现有props
  enableAtmosphere?: boolean;
  atmosphereIntensity?: number;
}

export function Earth({ 
  enableAtmosphere = true,
  atmosphereIntensity = 1.0,
  lightDirection,
  // ... 其他props
}: EarthProps) {
  return (
    <group name="earthRoot">
      {/* 现有地球渲染 */}
      <mesh>
        <sphereGeometry args={[earthInfo.size, 64, 32]} />
        <earthMaterial />
      </mesh>
      
      {/* 大气层效果 */}
      {enableAtmosphere && (
        <EarthAtmosphere
          earthRadius={earthInfo.size}
          lightDirection={lightDirection}
          intensity={atmosphereIntensity}
        />
      )}
    </group>
  );
}
```

### 2. 在SimpleTest.tsx中配置

```typescript
// src/SimpleTest.tsx
const DEFAULT_SIMPLE_COMPOSITION = {
  // ... 现有配置
  enableAtmosphere: true,
  atmosphereIntensity: 1.0,
  atmosphereColor: [135, 206, 235], // RGB天蓝色
  atmosphereScattering: 1.5
};

// 在渲染中应用
<Earth
  enableAtmosphere={composition.enableAtmosphere}
  atmosphereIntensity={composition.atmosphereIntensity}
  lightDirection={lightDirection}
/>
```

### 3. UI控制界面

```typescript
// src/scenes/simple/ui/controls/AtmosphereControls.tsx
import React from 'react';
import { Slider, Checkbox, ColorPicker } from '../../../ui/components';

interface AtmosphereControlsProps {
  composition: SimpleComposition;
  updateValue: (key: string, value: any) => void;
}

export function AtmosphereControls({ composition, updateValue }: AtmosphereControlsProps) {
  return (
    <div className="atmosphere-controls">
      <h3>大气层效果</h3>
      
      <Checkbox
        label="启用大气层"
        checked={composition.enableAtmosphere}
        onChange={(checked) => updateValue('enableAtmosphere', checked)}
      />
      
      {composition.enableAtmosphere && (
        <>
          <Slider
            label="强度"
            min={0}
            max={2}
            step={0.1}
            value={composition.atmosphereIntensity}
            onChange={(value) => updateValue('atmosphereIntensity', value)}
          />
          
          <ColorPicker
            label="颜色"
            value={composition.atmosphereColor}
            onChange={(color) => updateValue('atmosphereColor', color)}
          />
          
          <Slider
            label="散射强度"
            min={0.5}
            max={3}
            step={0.1}
            value={composition.atmosphereScattering}
            onChange={(value) => updateValue('atmosphereScattering', value)}
          />
        </>
      )}
    </div>
  );
}
```

## ⚡ 性能优化

### 1. LOD（细节层次）优化

```typescript
// src/scenes/simple/utils/atmosphereLOD.ts
export class AtmosphereLOD {
  static getGeometryDetail(cameraDistance: number, earthRadius: number): [number, number] {
    const normalizedDistance = cameraDistance / earthRadius;
    
    if (normalizedDistance < 2) {
      return [64, 32]; // 高质量
    } else if (normalizedDistance < 5) {
      return [32, 16]; // 中等质量
    } else {
      return [16, 8];  // 低质量
    }
  }
  
  static shouldRenderAtmosphere(cameraDistance: number, earthRadius: number): boolean {
    return cameraDistance < earthRadius * 10; // 距离太远时不渲染
  }
}
```

### 2. 着色器优化

```glsl
// 简化版片段着色器（性能优先）
void main() {
  vec3 viewDir = normalize(cameraPosition - vWorldPosition);
  
  // 使用预计算的查找表替代复杂计算
  float fresnel = 1.0 - dot(viewDir, vNormal);
  fresnel = fresnel * fresnel; // 平方代替pow
  
  // 简化光照计算
  float lightInfluence = 0.3 + 0.7 * max(0.0, dot(vNormal, -u_lightDirection));
  
  gl_FragColor = vec4(u_color * u_intensity * lightInfluence, fresnel * 0.6);
}
```

### 3. 渲染优化

```typescript
// 使用对象池减少GC压力
const atmospherePool = new ObjectPool(() => new THREE.Mesh());

// 基于帧率动态调整质量
export class AdaptiveAtmosphere {
  private frameRate = 60;
  private qualityLevel = 1.0;
  
  updateQuality() {
    if (this.frameRate < 30) {
      this.qualityLevel = Math.max(0.5, this.qualityLevel - 0.1);
    } else if (this.frameRate > 50) {
      this.qualityLevel = Math.min(1.0, this.qualityLevel + 0.05);
    }
  }
}
```

## 🎨 视觉效果调优

### 参数对照表

| 参数 | 推荐值 | 效果 |
|------|--------|------|
| 大气层厚度 | earthRadius * 0.05 | 自然的边缘厚度 |
| 菲涅尔指数 | 1.5 - 2.5 | 边缘锐度 |
| 光照影响 | 0.3 - 0.8 | 昼夜对比度 |
| 透明度 | 0.3 - 0.8 | 整体可见度 |
| 散射颜色 | RGB(135,206,235) | 标准天蓝色 |

### 不同场景配置

```typescript
// 配置预设
export const ATMOSPHERE_PRESETS = {
  // 真实地球
  realistic: {
    intensity: 1.0,
    color: [135, 206, 235],
    scattering: 1.5,
    thickness: 0.05
  },
  
  // 科幻风格
  scifi: {
    intensity: 1.5,
    color: [0, 150, 255],
    scattering: 2.0,
    thickness: 0.08
  },
  
  // 日落效果
  sunset: {
    intensity: 0.8,
    color: [255, 140, 60],
    scattering: 1.2,
    thickness: 0.04
  },
  
  // 性能优先
  performance: {
    intensity: 0.6,
    color: [135, 206, 235],
    scattering: 1.0,
    thickness: 0.03
  }
};
```

## 🧪 测试和验证

### 1. 视觉测试清单

- [ ] 大气层边缘是否平滑
- [ ] 光照面是否比背光面更亮
- [ ] 颜色是否自然
- [ ] 性能是否保持60fps
- [ ] 不同距离下的效果
- [ ] 地球自转时的连续性

### 2. 性能基准测试

```typescript
// src/tests/atmospherePerformance.test.ts
export class AtmospherePerformanceTest {
  static async runBenchmark() {
    const scenarios = [
      { distance: 1.5, quality: 'high' },
      { distance: 3.0, quality: 'medium' },
      { distance: 6.0, quality: 'low' }
    ];
    
    for (const scenario of scenarios) {
      const startTime = performance.now();
      // 渲染100帧
      const endTime = performance.now();
      const avgFrameTime = (endTime - startTime) / 100;
      console.log(`Scenario ${scenario.quality}: ${avgFrameTime.toFixed(2)}ms/frame`);
    }
  }
}
```

## 🔮 未来扩展

### 1. 高级效果

- **云层集成**：大气层与云层的交互
- **极光效果**：在极地区域添加极光
- **大气透视**：远距离物体的大气散射
- **动态天气**：雾霾、沙尘暴等天气效果

### 2. 技术升级

- **体积渲染**：更真实的3D大气效果
- **GPU粒子系统**：大气中的微粒效果
- **时间变化**：日出日落时的颜色变化
- **相机曝光**：HDR渲染和自动曝光

## 📚 参考资料

1. **物理基础**：
   - Rayleigh Scattering Theory
   - Mie Scattering Theory
   - 大气光学基础

2. **技术文档**：
   - Three.js ShaderMaterial
   - WebGL GLSL Reference
   - GPU Gems - Atmospheric Scattering

3. **实现案例**：
   - Unity3D大气散射
   - Unreal Engine天空系统
   - 其他开源实现

---

**文档版本**：v1.0  
**最后更新**：2025-01-14  
**适用版本**：LuBirth v1.x  
**技术要求**：Three.js r150+, WebGL 2.0