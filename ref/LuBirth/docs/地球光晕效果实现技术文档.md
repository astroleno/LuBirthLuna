# åœ°çƒå…‰æ™•æ•ˆæœå®ç°æŠ€æœ¯æ–‡æ¡£

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»å¦‚ä½•åœ¨LuBirthé¡¹ç›®ä¸­å®ç°åœ°çƒå…‰æ™•ï¼ˆå¤§æ°”æ•£å°„ï¼‰æ•ˆæœï¼Œè¯¥æ•ˆæœä»åœ°çƒè¡¨é¢æ‰©æ•£åˆ°ç©ºä¸­ï¼Œå¹¶æ ¹æ®å…‰ç…§é¢åŠ¨æ€è°ƒæ•´å¼ºåº¦ï¼Œè¥é€ çœŸå®çš„å¤§æ°”å±‚è§†è§‰æ•ˆæœã€‚

## ğŸ¯ æ•ˆæœç›®æ ‡

- **è§†è§‰æ•ˆæœ**ï¼šåœ°çƒè¾¹ç¼˜å‡ºç°æŸ”å’Œçš„è“è‰²å…‰æ™•
- **ç‰©ç†å‡†ç¡®æ€§**ï¼šå…‰ç…§é¢å…‰æ™•æ›´å¼ºï¼ŒèƒŒå…‰é¢å…‰æ™•è¾ƒå¼±
- **åŠ¨æ€å˜åŒ–**ï¼šéšåœ°çƒè‡ªè½¬å’Œå¤ªé˜³ä½ç½®å®æ—¶è°ƒæ•´
- **æ€§èƒ½ä¼˜åŒ–**ï¼šä¿æŒ60fpsæµç•…æ¸²æŸ“

## ğŸ”¬ æŠ€æœ¯åŸç†

### å¤§æ°”æ•£å°„ç‰©ç†å­¦

```
å¤ªé˜³å…‰ â†’ å¤§æ°”å±‚ â†’ ç‘åˆ©æ•£å°„ â†’ è“è‰²å…‰æ™•
         â†“
      ç±³æ°æ•£å°„ â†’ ç™½è‰²/æ©™è‰²è¾¹ç¼˜
```

**ç‘åˆ©æ•£å°„**ï¼šçŸ­æ³¢é•¿ï¼ˆè“å…‰ï¼‰æ•£å°„æ›´å¼ºçƒˆ
**ç±³æ°æ•£å°„**ï¼šè¾ƒå¤§ç²’å­æ•£å°„ï¼Œäº§ç”Ÿç™½è‰²å…‰æ™•
**å¸æ”¶æ•ˆåº”**ï¼šå¤§æ°”å±‚åšåº¦å½±å“å…‰æ™•å¼ºåº¦

### å®ç°ç­–ç•¥

1. **å‡ ä½•æ–¹æ³•**ï¼šä½¿ç”¨ç•¥å¤§äºåœ°çƒçš„çƒä½“ä½œä¸ºå¤§æ°”å±‚
2. **ç€è‰²å™¨æŠ€æœ¯**ï¼šåŸºäºè§†è§’å’Œå…‰ç…§æ–¹å‘è®¡ç®—æ•£å°„å¼ºåº¦
3. **æ··åˆæ¨¡å¼**ï¼šä½¿ç”¨åŠ æ³•æ··åˆå®ç°å‘å…‰æ•ˆæœ
4. **LODä¼˜åŒ–**ï¼šè·ç¦»è‡ªé€‚åº”è´¨é‡è°ƒæ•´

## ğŸ› ï¸ å®ç°æ–¹æ¡ˆ

### æ–¹æ¡ˆä¸€ï¼šåŸºç¡€çƒä½“å…‰æ™•ï¼ˆæ¨èå…¥é—¨ï¼‰

**ä¼˜ç‚¹**ï¼šå®ç°ç®€å•ï¼Œæ€§èƒ½è‰¯å¥½
**ç¼ºç‚¹**ï¼šç‰©ç†å‡†ç¡®æ€§ä¸€èˆ¬

```typescript
// src/scenes/simple/components/EarthAtmosphere.tsx
import React from 'react';
import * as THREE from 'three';
import { useFrame } from '@react-three/fiber';

interface EarthAtmosphereProps {
  earthRadius: number;
  lightDirection: THREE.Vector3;
  intensity?: number;
  color?: THREE.Color;
}

export function EarthAtmosphere({ 
  earthRadius, 
  lightDirection, 
  intensity = 1.0,
  color = new THREE.Color(0x87CEEB) // å¤©è“è‰²
}: EarthAtmosphereProps) {
  const atmosphereRef = React.useRef<THREE.Mesh>(null);
  
  // å¤§æ°”å±‚æè´¨
  const atmosphereMaterial = React.useMemo(() => {
    return new THREE.ShaderMaterial({
      uniforms: {
        u_lightDirection: { value: lightDirection },
        u_intensity: { value: intensity },
        u_color: { value: color },
        u_time: { value: 0 }
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vPosition = position;
          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 u_lightDirection;
        uniform float u_intensity;
        uniform vec3 u_color;
        
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        
        void main() {
          // è®¡ç®—è§†è§’æ–¹å‘
          vec3 viewDirection = normalize(cameraPosition - vWorldPosition);
          
          // è¾¹ç¼˜æ£€æµ‹ï¼ˆè²æ¶…å°”æ•ˆåº”ï¼‰
          float fresnel = 1.0 - abs(dot(viewDirection, vNormal));
          fresnel = pow(fresnel, 2.0);
          
          // å…‰ç…§å½±å“
          float lightInfluence = max(0.0, dot(vNormal, -u_lightDirection));
          lightInfluence = 0.3 + 0.7 * lightInfluence; // ä¿æŒæœ€å°äº®åº¦
          
          // æœ€ç»ˆé¢œè‰²
          vec3 finalColor = u_color * u_intensity * lightInfluence;
          float alpha = fresnel * 0.6; // é€æ˜åº¦
          
          gl_FragColor = vec4(finalColor, alpha);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide, // ä»å†…éƒ¨æ¸²æŸ“
      depthWrite: false
    });
  }, [lightDirection, intensity, color]);
  
  // å®æ—¶æ›´æ–°å…‰ç…§æ–¹å‘
  useFrame(() => {
    if (atmosphereMaterial.uniforms) {
      atmosphereMaterial.uniforms.u_lightDirection.value.copy(lightDirection);
    }
  });
  
  return (
    <mesh ref={atmosphereRef} material={atmosphereMaterial}>
      <sphereGeometry args={[earthRadius * 1.05, 64, 32]} />
    </mesh>
  );
}
```

### æ–¹æ¡ˆäºŒï¼šç‰©ç†å‡†ç¡®çš„å¤§æ°”æ•£å°„

**ä¼˜ç‚¹**ï¼šé«˜åº¦çœŸå®ï¼Œè§†è§‰æ•ˆæœå“è¶Š
**ç¼ºç‚¹**ï¼šè®¡ç®—å¤æ‚ï¼Œæ€§èƒ½è¦æ±‚é«˜

```typescript
// src/scenes/simple/components/PhysicalAtmosphere.tsx
import React from 'react';
import * as THREE from 'three';
import { useFrame } from '@react-three/fiber';

interface PhysicalAtmosphereProps {
  earthRadius: number;
  atmosphereHeight: number;
  lightDirection: THREE.Vector3;
  sunIntensity?: number;
}

export function PhysicalAtmosphere({ 
  earthRadius, 
  atmosphereHeight = earthRadius * 0.05,
  lightDirection,
  sunIntensity = 1.0
}: PhysicalAtmosphereProps) {
  const atmosphereRef = React.useRef<THREE.Mesh>(null);
  
  const atmosphereMaterial = React.useMemo(() => {
    return new THREE.ShaderMaterial({
      uniforms: {
        u_earthRadius: { value: earthRadius },
        u_atmosphereRadius: { value: earthRadius + atmosphereHeight },
        u_lightDirection: { value: lightDirection },
        u_sunIntensity: { value: sunIntensity },
        
        // ç‰©ç†å¸¸æ•°
        u_rayleighCoefficient: { value: new THREE.Vector3(0.0025, 0.0104, 0.0231) },
        u_mieCoefficient: { value: 0.005 },
        u_rayleighScaleHeight: { value: 8000.0 },
        u_mieScaleHeight: { value: 1200.0 },
        u_mieG: { value: 0.8 } // ç±³æ°æ•£å°„ä¸å¯¹ç§°å‚æ•°
      },
      vertexShader: `
        varying vec3 vWorldPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        
        void main() {
          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
          vNormal = normalize(normalMatrix * normal);
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float u_earthRadius;
        uniform float u_atmosphereRadius;
        uniform vec3 u_lightDirection;
        uniform float u_sunIntensity;
        
        // æ•£å°„å‚æ•°
        uniform vec3 u_rayleighCoefficient;
        uniform float u_mieCoefficient;
        uniform float u_rayleighScaleHeight;
        uniform float u_mieScaleHeight;
        uniform float u_mieG;
        
        varying vec3 vWorldPosition;
        varying vec3 vNormal;
        
        // è®¡ç®—å…‰çº¿ä¸çƒé¢çš„äº¤ç‚¹
        vec2 raySphereIntersect(vec3 rayOrigin, vec3 rayDir, float sphereRadius) {
          float a = dot(rayDir, rayDir);
          float b = 2.0 * dot(rayOrigin, rayDir);
          float c = dot(rayOrigin, rayOrigin) - sphereRadius * sphereRadius;
          float discriminant = b * b - 4.0 * a * c;
          
          if (discriminant < 0.0) return vec2(-1.0);
          
          float sqrt_d = sqrt(discriminant);
          return vec2((-b - sqrt_d) / (2.0 * a), (-b + sqrt_d) / (2.0 * a));
        }
        
        // ç‘åˆ©æ•£å°„ç›¸å‡½æ•°
        float rayleighPhase(float cosTheta) {
          return 3.0 / (16.0 * 3.14159265) * (1.0 + cosTheta * cosTheta);
        }
        
        // ç±³æ°æ•£å°„ç›¸å‡½æ•°
        float miePhase(float cosTheta, float g) {
          float g2 = g * g;
          float numerator = 3.0 * (1.0 - g2) * (1.0 + cosTheta * cosTheta);
          float denominator = 8.0 * 3.14159265 * (2.0 + g2) * pow(1.0 + g2 - 2.0 * g * cosTheta, 1.5);
          return numerator / denominator;
        }
        
        // è®¡ç®—å¤§æ°”å¯†åº¦
        float atmosphereDensity(float height, float scaleHeight) {
          return exp(-height / scaleHeight);
        }
        
        // ä¸»è¦æ•£å°„è®¡ç®—
        vec3 calculateScattering(vec3 rayStart, vec3 rayDir, float rayLength) {
          const int SAMPLE_COUNT = 16;
          float stepSize = rayLength / float(SAMPLE_COUNT);
          
          vec3 rayleighScattering = vec3(0.0);
          vec3 mieScattering = vec3(0.0);
          
          for (int i = 0; i < SAMPLE_COUNT; i++) {
            vec3 samplePos = rayStart + rayDir * (float(i) + 0.5) * stepSize;
            float height = length(samplePos) - u_earthRadius;
            
            // è®¡ç®—å¯†åº¦
            float rayleighDensity = atmosphereDensity(height, u_rayleighScaleHeight);
            float mieDensity = atmosphereDensity(height, u_mieScaleHeight);
            
            // ç´¯ç§¯æ•£å°„
            rayleighScattering += u_rayleighCoefficient * rayleighDensity * stepSize;
            mieScattering += vec3(u_mieCoefficient) * mieDensity * stepSize;
          }
          
          // è®¡ç®—ç›¸å‡½æ•°
          float cosTheta = dot(rayDir, -u_lightDirection);
          float rayleighPhaseValue = rayleighPhase(cosTheta);
          float miePhaseValue = miePhase(cosTheta, u_mieG);
          
          // æœ€ç»ˆæ•£å°„é¢œè‰²
          vec3 finalColor = rayleighScattering * rayleighPhaseValue + 
                           mieScattering * miePhaseValue;
          
          return finalColor * u_sunIntensity;
        }
        
        void main() {
          vec3 rayOrigin = cameraPosition;
          vec3 rayDir = normalize(vWorldPosition - cameraPosition);
          
          // è®¡ç®—ä¸å¤§æ°”å±‚çš„äº¤ç‚¹
          vec2 atmosphereIntersect = raySphereIntersect(rayOrigin, rayDir, u_atmosphereRadius);
          vec2 earthIntersect = raySphereIntersect(rayOrigin, rayDir, u_earthRadius);
          
          if (atmosphereIntersect.x < 0.0) {
            discard; // å…‰çº¿æœªå‡»ä¸­å¤§æ°”å±‚
          }
          
          float rayStart = max(0.0, atmosphereIntersect.x);
          float rayEnd = atmosphereIntersect.y;
          
          // å¦‚æœå…‰çº¿å‡»ä¸­åœ°çƒï¼Œåˆ™æˆªæ–­åˆ°åœ°çƒè¡¨é¢
          if (earthIntersect.x > 0.0) {
            rayEnd = min(rayEnd, earthIntersect.x);
          }
          
          float rayLength = rayEnd - rayStart;
          vec3 scattering = calculateScattering(
            rayOrigin + rayDir * rayStart, 
            rayDir, 
            rayLength
          );
          
          // åº”ç”¨æ›å…‰å’Œè‰²è°ƒæ˜ å°„
          scattering = 1.0 - exp(-scattering * 2.0);
          
          gl_FragColor = vec4(scattering, 1.0);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide,
      depthWrite: false
    });
  }, [earthRadius, atmosphereHeight, lightDirection, sunIntensity]);
  
  useFrame(() => {
    if (atmosphereMaterial.uniforms) {
      atmosphereMaterial.uniforms.u_lightDirection.value.copy(lightDirection);
    }
  });
  
  return (
    <mesh ref={atmosphereRef} material={atmosphereMaterial}>
      <sphereGeometry args={[earthRadius + atmosphereHeight, 64, 32]} />
    </mesh>
  );
}
```

### æ–¹æ¡ˆä¸‰ï¼šåˆ†å±‚å¤§æ°”æ•ˆæœ

**ä¼˜ç‚¹**ï¼šæ€§èƒ½ä¸æ•ˆæœå¹³è¡¡ï¼Œå¯é…ç½®æ€§å¼º
**ç¼ºç‚¹**ï¼šå®ç°å¤æ‚åº¦ä¸­ç­‰

```typescript
// src/scenes/simple/components/LayeredAtmosphere.tsx
import React from 'react';
import * as THREE from 'three';

interface LayeredAtmosphereProps {
  earthRadius: number;
  lightDirection: THREE.Vector3;
  layers?: AtmosphereLayer[];
}

interface AtmosphereLayer {
  height: number;        // ç›¸å¯¹äºåœ°çƒè¡¨é¢çš„é«˜åº¦
  color: THREE.Color;    // å±‚çš„é¢œè‰²
  intensity: number;     // å¼ºåº¦
  scattering: number;    // æ•£å°„å¼ºåº¦
}

export function LayeredAtmosphere({ 
  earthRadius, 
  lightDirection,
  layers = [
    { height: 0.02, color: new THREE.Color(0x87CEEB), intensity: 0.8, scattering: 1.5 },
    { height: 0.04, color: new THREE.Color(0x4169E1), intensity: 0.4, scattering: 1.0 },
    { height: 0.06, color: new THREE.Color(0x191970), intensity: 0.2, scattering: 0.5 }
  ]
}: LayeredAtmosphereProps) {
  
  return (
    <>
      {layers.map((layer, index) => (
        <mesh key={index}>
          <sphereGeometry args={[earthRadius * (1 + layer.height), 64, 32]} />
          <shaderMaterial
            uniforms={{
              u_lightDirection: { value: lightDirection },
              u_color: { value: layer.color },
              u_intensity: { value: layer.intensity },
              u_scattering: { value: layer.scattering }
            }}
            vertexShader={`
              varying vec3 vNormal;
              varying vec3 vWorldPosition;
              
              void main() {
                vNormal = normalize(normalMatrix * normal);
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `}
            fragmentShader={`
              uniform vec3 u_lightDirection;
              uniform vec3 u_color;
              uniform float u_intensity;
              uniform float u_scattering;
              
              varying vec3 vNormal;
              varying vec3 vWorldPosition;
              
              void main() {
                vec3 viewDir = normalize(cameraPosition - vWorldPosition);
                
                // è¾¹ç¼˜å¼ºåº¦
                float fresnel = 1.0 - abs(dot(viewDir, vNormal));
                fresnel = pow(fresnel, u_scattering);
                
                // å…‰ç…§å½±å“
                float lightDot = dot(vNormal, -u_lightDirection);
                float lightInfluence = 0.2 + 0.8 * max(0.0, lightDot);
                
                vec3 finalColor = u_color * u_intensity * lightInfluence;
                float alpha = fresnel * 0.3;
                
                gl_FragColor = vec4(finalColor, alpha);
              }
            `}
            transparent
            blending={THREE.AdditiveBlending}
            side={THREE.BackSide}
            depthWrite={false}
          />
        </mesh>
      ))}
    </>
  );
}
```

## ğŸ”§ é›†æˆåˆ°ç°æœ‰ç³»ç»Ÿ

### 1. åœ¨Earthç»„ä»¶ä¸­é›†æˆ

```typescript
// src/scenes/simple/api/components/Earth.tsx
import { EarthAtmosphere } from '../../../components/EarthAtmosphere';

interface EarthProps {
  // ... ç°æœ‰props
  enableAtmosphere?: boolean;
  atmosphereIntensity?: number;
}

export function Earth({ 
  enableAtmosphere = true,
  atmosphereIntensity = 1.0,
  lightDirection,
  // ... å…¶ä»–props
}: EarthProps) {
  return (
    <group name="earthRoot">
      {/* ç°æœ‰åœ°çƒæ¸²æŸ“ */}
      <mesh>
        <sphereGeometry args={[earthInfo.size, 64, 32]} />
        <earthMaterial />
      </mesh>
      
      {/* å¤§æ°”å±‚æ•ˆæœ */}
      {enableAtmosphere && (
        <EarthAtmosphere
          earthRadius={earthInfo.size}
          lightDirection={lightDirection}
          intensity={atmosphereIntensity}
        />
      )}
    </group>
  );
}
```

### 2. åœ¨SimpleTest.tsxä¸­é…ç½®

```typescript
// src/SimpleTest.tsx
const DEFAULT_SIMPLE_COMPOSITION = {
  // ... ç°æœ‰é…ç½®
  enableAtmosphere: true,
  atmosphereIntensity: 1.0,
  atmosphereColor: [135, 206, 235], // RGBå¤©è“è‰²
  atmosphereScattering: 1.5
};

// åœ¨æ¸²æŸ“ä¸­åº”ç”¨
<Earth
  enableAtmosphere={composition.enableAtmosphere}
  atmosphereIntensity={composition.atmosphereIntensity}
  lightDirection={lightDirection}
/>
```

### 3. UIæ§åˆ¶ç•Œé¢

```typescript
// src/scenes/simple/ui/controls/AtmosphereControls.tsx
import React from 'react';
import { Slider, Checkbox, ColorPicker } from '../../../ui/components';

interface AtmosphereControlsProps {
  composition: SimpleComposition;
  updateValue: (key: string, value: any) => void;
}

export function AtmosphereControls({ composition, updateValue }: AtmosphereControlsProps) {
  return (
    <div className="atmosphere-controls">
      <h3>å¤§æ°”å±‚æ•ˆæœ</h3>
      
      <Checkbox
        label="å¯ç”¨å¤§æ°”å±‚"
        checked={composition.enableAtmosphere}
        onChange={(checked) => updateValue('enableAtmosphere', checked)}
      />
      
      {composition.enableAtmosphere && (
        <>
          <Slider
            label="å¼ºåº¦"
            min={0}
            max={2}
            step={0.1}
            value={composition.atmosphereIntensity}
            onChange={(value) => updateValue('atmosphereIntensity', value)}
          />
          
          <ColorPicker
            label="é¢œè‰²"
            value={composition.atmosphereColor}
            onChange={(color) => updateValue('atmosphereColor', color)}
          />
          
          <Slider
            label="æ•£å°„å¼ºåº¦"
            min={0.5}
            max={3}
            step={0.1}
            value={composition.atmosphereScattering}
            onChange={(value) => updateValue('atmosphereScattering', value)}
          />
        </>
      )}
    </div>
  );
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–

### 1. LODï¼ˆç»†èŠ‚å±‚æ¬¡ï¼‰ä¼˜åŒ–

```typescript
// src/scenes/simple/utils/atmosphereLOD.ts
export class AtmosphereLOD {
  static getGeometryDetail(cameraDistance: number, earthRadius: number): [number, number] {
    const normalizedDistance = cameraDistance / earthRadius;
    
    if (normalizedDistance < 2) {
      return [64, 32]; // é«˜è´¨é‡
    } else if (normalizedDistance < 5) {
      return [32, 16]; // ä¸­ç­‰è´¨é‡
    } else {
      return [16, 8];  // ä½è´¨é‡
    }
  }
  
  static shouldRenderAtmosphere(cameraDistance: number, earthRadius: number): boolean {
    return cameraDistance < earthRadius * 10; // è·ç¦»å¤ªè¿œæ—¶ä¸æ¸²æŸ“
  }
}
```

### 2. ç€è‰²å™¨ä¼˜åŒ–

```glsl
// ç®€åŒ–ç‰ˆç‰‡æ®µç€è‰²å™¨ï¼ˆæ€§èƒ½ä¼˜å…ˆï¼‰
void main() {
  vec3 viewDir = normalize(cameraPosition - vWorldPosition);
  
  // ä½¿ç”¨é¢„è®¡ç®—çš„æŸ¥æ‰¾è¡¨æ›¿ä»£å¤æ‚è®¡ç®—
  float fresnel = 1.0 - dot(viewDir, vNormal);
  fresnel = fresnel * fresnel; // å¹³æ–¹ä»£æ›¿pow
  
  // ç®€åŒ–å…‰ç…§è®¡ç®—
  float lightInfluence = 0.3 + 0.7 * max(0.0, dot(vNormal, -u_lightDirection));
  
  gl_FragColor = vec4(u_color * u_intensity * lightInfluence, fresnel * 0.6);
}
```

### 3. æ¸²æŸ“ä¼˜åŒ–

```typescript
// ä½¿ç”¨å¯¹è±¡æ± å‡å°‘GCå‹åŠ›
const atmospherePool = new ObjectPool(() => new THREE.Mesh());

// åŸºäºå¸§ç‡åŠ¨æ€è°ƒæ•´è´¨é‡
export class AdaptiveAtmosphere {
  private frameRate = 60;
  private qualityLevel = 1.0;
  
  updateQuality() {
    if (this.frameRate < 30) {
      this.qualityLevel = Math.max(0.5, this.qualityLevel - 0.1);
    } else if (this.frameRate > 50) {
      this.qualityLevel = Math.min(1.0, this.qualityLevel + 0.05);
    }
  }
}
```

## ğŸ¨ è§†è§‰æ•ˆæœè°ƒä¼˜

### å‚æ•°å¯¹ç…§è¡¨

| å‚æ•° | æ¨èå€¼ | æ•ˆæœ |
|------|--------|------|
| å¤§æ°”å±‚åšåº¦ | earthRadius * 0.05 | è‡ªç„¶çš„è¾¹ç¼˜åšåº¦ |
| è²æ¶…å°”æŒ‡æ•° | 1.5 - 2.5 | è¾¹ç¼˜é”åº¦ |
| å…‰ç…§å½±å“ | 0.3 - 0.8 | æ˜¼å¤œå¯¹æ¯”åº¦ |
| é€æ˜åº¦ | 0.3 - 0.8 | æ•´ä½“å¯è§åº¦ |
| æ•£å°„é¢œè‰² | RGB(135,206,235) | æ ‡å‡†å¤©è“è‰² |

### ä¸åŒåœºæ™¯é…ç½®

```typescript
// é…ç½®é¢„è®¾
export const ATMOSPHERE_PRESETS = {
  // çœŸå®åœ°çƒ
  realistic: {
    intensity: 1.0,
    color: [135, 206, 235],
    scattering: 1.5,
    thickness: 0.05
  },
  
  // ç§‘å¹»é£æ ¼
  scifi: {
    intensity: 1.5,
    color: [0, 150, 255],
    scattering: 2.0,
    thickness: 0.08
  },
  
  // æ—¥è½æ•ˆæœ
  sunset: {
    intensity: 0.8,
    color: [255, 140, 60],
    scattering: 1.2,
    thickness: 0.04
  },
  
  // æ€§èƒ½ä¼˜å…ˆ
  performance: {
    intensity: 0.6,
    color: [135, 206, 235],
    scattering: 1.0,
    thickness: 0.03
  }
};
```

## ğŸ§ª æµ‹è¯•å’ŒéªŒè¯

### 1. è§†è§‰æµ‹è¯•æ¸…å•

- [ ] å¤§æ°”å±‚è¾¹ç¼˜æ˜¯å¦å¹³æ»‘
- [ ] å…‰ç…§é¢æ˜¯å¦æ¯”èƒŒå…‰é¢æ›´äº®
- [ ] é¢œè‰²æ˜¯å¦è‡ªç„¶
- [ ] æ€§èƒ½æ˜¯å¦ä¿æŒ60fps
- [ ] ä¸åŒè·ç¦»ä¸‹çš„æ•ˆæœ
- [ ] åœ°çƒè‡ªè½¬æ—¶çš„è¿ç»­æ€§

### 2. æ€§èƒ½åŸºå‡†æµ‹è¯•

```typescript
// src/tests/atmospherePerformance.test.ts
export class AtmospherePerformanceTest {
  static async runBenchmark() {
    const scenarios = [
      { distance: 1.5, quality: 'high' },
      { distance: 3.0, quality: 'medium' },
      { distance: 6.0, quality: 'low' }
    ];
    
    for (const scenario of scenarios) {
      const startTime = performance.now();
      // æ¸²æŸ“100å¸§
      const endTime = performance.now();
      const avgFrameTime = (endTime - startTime) / 100;
      console.log(`Scenario ${scenario.quality}: ${avgFrameTime.toFixed(2)}ms/frame`);
    }
  }
}
```

## ğŸ”® æœªæ¥æ‰©å±•

### 1. é«˜çº§æ•ˆæœ

- **äº‘å±‚é›†æˆ**ï¼šå¤§æ°”å±‚ä¸äº‘å±‚çš„äº¤äº’
- **æå…‰æ•ˆæœ**ï¼šåœ¨æåœ°åŒºåŸŸæ·»åŠ æå…‰
- **å¤§æ°”é€è§†**ï¼šè¿œè·ç¦»ç‰©ä½“çš„å¤§æ°”æ•£å°„
- **åŠ¨æ€å¤©æ°”**ï¼šé›¾éœ¾ã€æ²™å°˜æš´ç­‰å¤©æ°”æ•ˆæœ

### 2. æŠ€æœ¯å‡çº§

- **ä½“ç§¯æ¸²æŸ“**ï¼šæ›´çœŸå®çš„3Då¤§æ°”æ•ˆæœ
- **GPUç²’å­ç³»ç»Ÿ**ï¼šå¤§æ°”ä¸­çš„å¾®ç²’æ•ˆæœ
- **æ—¶é—´å˜åŒ–**ï¼šæ—¥å‡ºæ—¥è½æ—¶çš„é¢œè‰²å˜åŒ–
- **ç›¸æœºæ›å…‰**ï¼šHDRæ¸²æŸ“å’Œè‡ªåŠ¨æ›å…‰

## ğŸ“š å‚è€ƒèµ„æ–™

1. **ç‰©ç†åŸºç¡€**ï¼š
   - Rayleigh Scattering Theory
   - Mie Scattering Theory
   - å¤§æ°”å…‰å­¦åŸºç¡€

2. **æŠ€æœ¯æ–‡æ¡£**ï¼š
   - Three.js ShaderMaterial
   - WebGL GLSL Reference
   - GPU Gems - Atmospheric Scattering

3. **å®ç°æ¡ˆä¾‹**ï¼š
   - Unity3Då¤§æ°”æ•£å°„
   - Unreal Engineå¤©ç©ºç³»ç»Ÿ
   - å…¶ä»–å¼€æºå®ç°

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
**æœ€åæ›´æ–°**ï¼š2025-01-14  
**é€‚ç”¨ç‰ˆæœ¬**ï¼šLuBirth v1.x  
**æŠ€æœ¯è¦æ±‚**ï¼šThree.js r150+, WebGL 2.0