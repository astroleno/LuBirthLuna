# 云层厚度实施计划 v3.1 - 场景感知混合渲染（评审优化版）

## 项目概述

基于LuBirth项目的**双场景需求**（地球全景 + 出生点近景），制定一个**场景感知**的云层厚度增强方案。目标是在**全景场景**保持高性能的同时，在**近景场景**提供强烈的体积感和厚度感。

**v3.1更新**：基于专业评审建议，重点解决渲染一致性、切换稳定性、性能预算管理等关键问题。

## 场景需求分析

### 场景1：地球全景
- **相机距离**：20-50km
- **视角**：俯视地球，需要看到全球云层分布
- **需求**：云层厚度感，但不能影响整体性能
- **特点**：云层相对较小，细节要求不高
- **性能目标**：60+ FPS

### 场景2：出生点上方近景
- **相机距离**：2-5km
- **视角**：仰视云层，需要强烈的体积感
- **需求**：强烈的云层厚度感和体积感
- **特点**：云层占屏幕大部分，细节要求极高
- **性能目标**：35+ FPS

## 核心方案：场景感知混合渲染

### 设计理念
- **全景场景**：使用着色器厚度模拟，性能优先
- **近景场景**：使用真实多层渲染，效果优先
- **动态切换**：根据场景自动调整渲染策略
- **平滑过渡**：避免突兀的视觉切换
- **渲染一致性**：统一相位函数、光照强度、颜色映射
- **性能预算**：明确的帧时预算和自适应降级策略

### 技术架构
```typescript
// 场景类型检测（带滞回逻辑）
const getSceneTypeWithHysteresis = (
  cameraPosition: Vector3, 
  earthPosition: Vector3, 
  currentType: string
) => {
  const distance = cameraPosition.distanceTo(earthPosition);
  const height = cameraPosition.y - earthPosition.y;
  
  // 滞回逻辑：避免相机微动引起的抖动
  if (currentType === 'panorama' && distance < 8 && height < 5) {
    return 'closeup';
  } else if (currentType === 'closeup' && (distance > 10 || height > 7)) {
    return 'panorama';
  }
  
  return currentType;
};

// 过渡插值系统
const transitionDuration = 0.5; // 0.5秒过渡时间
const interpolateParameters = (from: any, to: any, t: number) => {
  // 平滑插值所有参数：厚度倍数、散射强度、层数、步数、分辨率
  return {
    thickness: THREE.MathUtils.lerp(from.thickness, to.thickness, t),
    scattering: THREE.MathUtils.lerp(from.scattering, to.scattering, t),
    layers: Math.round(THREE.MathUtils.lerp(from.layers, to.layers, t)),
    steps: Math.round(THREE.MathUtils.lerp(from.steps, to.steps, t)),
    resolution: THREE.MathUtils.lerp(from.resolution, to.resolution, t)
  };
};

// 统一的相位函数（Henyey-Greenstein）
const henneyGreenstein = (cosTheta: number, g: number) => {
  return (1 - g * g) / (4 * Math.PI * Math.pow(1 + g * g - 2 * g * cosTheta, 1.5));
};

// 场景特定的渲染策略
const getSceneStrategy = (sceneType: string) => {
  if (sceneType === 'closeup') {
    return {
      // 近景：强烈体积感
      layers: 12,
      useRealLayers: true,
      useThicknessShader: false,
      usePOM: true,
      useVolumeScattering: true,
      geometryDetail: 'ultra',
      targetFPS: 35,
      // 统一光照参数
      phaseFunction: henneyGreenstein,
      scatteringG: 0.3, // 前向散射参数
      volumeSteps: 16,
      volumeResolution: 1.0
    };
  } else {
    return {
      // 全景：性能优先
      layers: 3,
      useRealLayers: false,
      useThicknessShader: true,
      usePOM: false,
      useVolumeScattering: false,
      geometryDetail: 'medium',
      targetFPS: 60,
      // 统一光照参数
      phaseFunction: henneyGreenstein,
      scatteringG: 0.3, // 与近景保持一致
      thicknessLayers: 8,
      renderResolution: 0.5 // 半分辨率渲染
    };
  }
};

// 自适应性能降级
const getPerformanceLevel = (fps: number) => {
  if (fps < 30) return 'emergency';
  if (fps < 45) return 'low';
  if (fps < 55) return 'medium';
  return 'high';
};

const adjustStrategy = (strategy: any, level: string) => {
  switch (level) {
    case 'emergency':
      return { 
        ...strategy, 
        resolution: 0.5, 
        steps: 8, 
        layers: 3, 
        usePOM: false,
        volumeSteps: 8
      };
    case 'low':
      return { 
        ...strategy, 
        resolution: 0.67, 
        steps: 12, 
        layers: 6, 
        usePOM: false,
        volumeSteps: 12
      };
    case 'medium':
      return { 
        ...strategy, 
        resolution: 0.8, 
        steps: 16, 
        layers: 8, 
        usePOM: true,
        volumeSteps: 16
      };
    default:
      return strategy;
  }
};
```

---

## 第一阶段：场景感知系统（1-2天）

### 目标
- 实现场景类型检测
- 建立场景感知的渲染策略
- 创建基础的双场景云层系统

### 任务清单

#### 1.1 场景检测系统
```typescript
// 添加到 SimpleTest.tsx
export function SceneAwareCloudSystem({ 
  cameraPosition, 
  earthPosition, 
  baseRadius, 
  texture 
}: SceneAwareCloudSystemProps) {
  const [sceneType, setSceneType] = useState<'panorama' | 'closeup'>('panorama');
  const [strategy, setStrategy] = useState<RenderingStrategy>(getSceneStrategy('panorama'));
  
  // 场景检测
  useEffect(() => {
    const distance = cameraPosition.distanceTo(earthPosition);
    const height = cameraPosition.y - earthPosition.y;
    
    const newSceneType = (distance < 8 && height < 5) ? 'closeup' : 'panorama';
    
    if (newSceneType !== sceneType) {
      setSceneType(newSceneType);
      setStrategy(getSceneStrategy(newSceneType));
      console.log(`[SceneAware] 切换到${newSceneType}场景，策略:`, strategy);
    }
  }, [cameraPosition, earthPosition]);
  
  return (
    <AdaptiveCloudRenderer 
      sceneType={sceneType}
      strategy={strategy}
      baseRadius={baseRadius}
      texture={texture}
    />
  );
}
```

#### 1.2 基础双场景渲染器
```typescript
// 创建 AdaptiveCloudRenderer.tsx
export function AdaptiveCloudRenderer({ 
  sceneType, 
  strategy, 
  baseRadius, 
  texture 
}: AdaptiveCloudRendererProps) {
  return (
    <>
      {/* 基础3层：始终渲染 */}
      <CloudLayer 
        radius={baseRadius * 1.0006}
        texture={texture}
        opacity={0.7}
        useThicknessShader={strategy.useThicknessShader}
        thicknessLayers={8}
      />
      
      <CloudLayer 
        radius={baseRadius * 1.0012}
        texture={texture}
        opacity={0.5}
        useThicknessShader={strategy.useThicknessShader}
        thicknessLayers={8}
      />
      
      <CloudLayer 
        radius={baseRadius * 1.0018}
        texture={texture}
        opacity={0.3}
        useThicknessShader={strategy.useThicknessShader}
        thicknessLayers={8}
      />
      
      {/* 近景增强层：仅在近景场景渲染 */}
      {sceneType === 'closeup' && (
        <>
          {/* 真实多层渲染 */}
          {Array.from({ length: 9 }).map((_, i) => (
            <CloudLayer 
              key={`enhance-${i}`}
              radius={baseRadius * (1.0024 + i * 0.0006)}
              texture={texture}
              opacity={0.2}
              useThicknessShader={false}
            />
          ))}
          
          {/* POM增强层 */}
          <POMCloudLayer 
            radius={baseRadius * 1.008}
            texture={texture}
            pomSteps={16}
            useVolumeScattering={true}
          />
        </>
      )}
    </>
  );
}
```

#### 1.3 参数配置
```typescript
// 添加到 SimpleComposition.ts
export interface SimpleComposition {
  // 场景感知控制
  cloudSceneAware: boolean;          // 启用场景感知，默认true
  cloudPanoramaLayers: number;       // 全景场景层数，默认3
  cloudCloseupLayers: number;        // 近景场景层数，默认12
  cloudSceneTransitionDistance: number; // 场景切换距离，默认8
  
  // 全景场景参数
  cloudPanoramaThickness: number;    // 全景厚度倍数，默认1.0
  cloudPanoramaThicknessLayers: number; // 全景厚度模拟层数，默认8
  
  // 近景场景参数
  cloudCloseupUsePOM: boolean;       // 近景启用POM，默认true
  cloudCloseupPOMSteps: number;      // POM步数，默认16
  cloudCloseupUseVolumeScattering: boolean; // 近景启用体积散射，默认true
}
```

### 验收标准
- [ ] 场景类型检测正常工作
- [ ] 全景场景使用3层基础渲染
- [ ] 近景场景使用12层增强渲染
- [ ] 场景切换平滑无突兀
- [ ] 性能监控显示预期帧率

---

## 第二阶段：全景场景着色器厚度模拟（2-3天）

### 目标
- 实现全景场景的着色器厚度模拟
- 在3层基础上模拟8层厚度效果
- 优化性能，确保60+ FPS

### 任务清单

#### 2.1 全景厚度着色器（评审优化版）
```typescript
// 在 Clouds.tsx 中添加全景厚度着色器
const panoramaThicknessShader = `
  uniform float cloudThickness;        // 厚度倍数
  uniform float thicknessVariation;    // 厚度变化
  uniform int thicknessLayers;         // 模拟层数
  uniform float scatteringG;           // 相位函数参数
  uniform vec3 lightDir;               // 光照方向
  uniform float renderResolution;      // 渲染分辨率比例
  
  // 统一的Henyey-Greenstein相位函数
  float henneyGreenstein(float cosTheta, float g) {
    return (1.0 - g * g) / (4.0 * 3.14159 * pow(1.0 + g * g - 2.0 * g * cosTheta, 1.5));
  }
  
  // 蓝噪声抖动
  float blueNoise(vec2 uv) {
    return fract(sin(dot(uv * 100.0, vec2(12.9898, 78.233))) * 43758.5453);
  }
  
  // 全景厚度采样：优化性能 + 抗伪影
  vec3 samplePanoramaThickness(vec2 uv, float depth, vec3 normal) {
    vec3 color = vec3(0.0);
    float totalWeight = 0.0;
    
    // 各向异性偏移：基于法线方向
    vec3 tangent = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));
    vec3 bitangent = cross(normal, tangent);
    
    // 减少采样次数，优化性能
    for (int i = 0; i < 4; i++) {
      if (i >= thicknessLayers) break;
      
      float layerDepth = float(i) / float(thicknessLayers);
      float weight = exp(-abs(depth - layerDepth) * 5.0);
      
      // 各向异性偏移 + 蓝噪声抖动
      float noise = blueNoise(uv + float(i) * 0.1);
      vec2 anisotropicOffset = vec2(
        dot(tangent.xy, vec2(1.0, 0.0)) * 0.005,
        dot(bitangent.xy, vec2(0.0, 1.0)) * 0.005
      );
      
      vec2 layerUV = uv + anisotropicOffset + (noise - 0.5) * 0.002;
      
      vec3 layerColor = texture2D(map, layerUV).rgb;
      color += layerColor * weight;
      totalWeight += weight;
    }
    
    return color / totalWeight;
  }
  
  void main() {
    vec2 uv = vUv;
    float depth = texture2D(map, uv).r;
    vec3 normal = normalize(vNormal);
    
    // 使用全景厚度采样
    vec3 thicknessColor = samplePanoramaThickness(uv, depth, normal);
    
    // 应用厚度变化
    float variation = 1.0 + sin(uv.x * 5.0) * thicknessVariation;
    thicknessColor *= variation;
    
    // 统一相位函数计算
    float cosTheta = dot(normal, normalize(lightDir));
    float phase = henneyGreenstein(cosTheta, scatteringG);
    thicknessColor *= phase;
    
    gl_FragColor = vec4(thicknessColor, 1.0);
  }
`;
```

#### 2.2 全景云层组件
```typescript
// 创建 PanoramaCloudLayer.tsx
export function PanoramaCloudLayer({ 
  radius, 
  texture, 
  thicknessLayers = 8,
  thicknessVariation = 0.3
}: PanoramaCloudLayerProps) {
  const material = useMemo(() => new THREE.ShaderMaterial({
    uniforms: {
      map: { value: texture },
      cloudThickness: { value: 1.0 },
      thicknessVariation: { value: thicknessVariation },
      thicknessLayers: { value: thicknessLayers },
      // ... 其他uniforms
    },
    vertexShader: `
      // 标准顶点着色器
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: panoramaThicknessShader,
    transparent: true,
    depthTest: true,
    depthWrite: false
  }), [texture, thicknessLayers, thicknessVariation]);
  
  return (
    <mesh>
      <sphereGeometry args={[radius, 64, 32]} />
      <primitive object={material} />
    </mesh>
  );
}
```

#### 2.3 性能优化（评审增强版）
```typescript
// 全景场景性能优化
const optimizePanoramaPerformance = () => {
  return {
    // 几何体优化
    geometryDetail: { segments: 64, rings: 32 },
    
    // 纹理优化
    textureResolution: '4k',
    
    // 着色器优化
    shaderOptimizations: {
      reduceSampling: true,
      simplifyCalculations: true,
      useLowPrecision: true,
      // 评审建议：半分辨率渲染 + 引导上采样
      halfResolution: true,
      guidedUpsampling: true
    },
    
    // 渲染优化
    renderOptimizations: {
      frustumCulling: true,
      occlusionCulling: false,
      instancing: false,
      // 评审建议：TAA抗闪烁
      temporalAA: true,
      blueNoiseJitter: true
    },
    
    // 性能预算管理
    performanceBudget: {
      targetFrameTime: 16.6, // 60 FPS
      maxFrameTime: 20.0,    // 50 FPS
      emergencyFrameTime: 33.3 // 30 FPS
    }
  };
};
```

### 验收标准（评审优化版）
- [ ] 全景场景有明显的厚度感
- [ ] 着色器厚度模拟效果自然，无掠视角伪影
- [ ] 性能保持在60+ FPS（p95 ≤ 16.6ms）
- [ ] 内存使用增长 < 20%
- [ ] 与现有光照系统兼容
- [ ] 统一相位函数，与近景场景光照一致
- [ ] 蓝噪声抖动 + TAA抗闪烁效果良好
- [ ] 半分辨率渲染 + 引导上采样性能提升明显

---

## 第三阶段：近景场景真实多层渲染（3-4天）

### 目标
- 实现近景场景的12层真实云层
- 添加POM视差映射
- 实现体积散射效果
- 确保35+ FPS

### 任务清单

#### 3.1 真实多层渲染系统
```typescript
// 创建 CloseupCloudSystem.tsx
export function CloseupCloudSystem({ 
  baseRadius, 
  texture 
}: CloseupCloudSystemProps) {
  const layers = 12;
  const layerSpacing = 0.0006;
  
  return (
    <>
      {/* 基础3层 */}
      {Array.from({ length: 3 }).map((_, i) => (
        <CloudLayer 
          key={`base-${i}`}
          radius={baseRadius * (1.0006 + i * layerSpacing)}
          texture={texture}
          opacity={0.7 - i * 0.1}
          useThicknessShader={false}
        />
      ))}
      
      {/* 增强9层 */}
      {Array.from({ length: 9 }).map((_, i) => (
        <CloudLayer 
          key={`enhance-${i}`}
          radius={baseRadius * (1.0018 + i * layerSpacing)}
          texture={texture}
          opacity={0.3 - i * 0.02}
          useThicknessShader={false}
        />
      ))}
      
      {/* POM增强层 */}
      <POMCloudLayer 
        radius={baseRadius * 1.008}
        texture={texture}
        pomSteps={16}
        useVolumeScattering={true}
        volumeDensity={0.3}
        scatteringStrength={0.5}
      />
    </>
  );
}
```

#### 3.2 POM视差映射（评审优化版）
```typescript
// 创建 POMCloudLayer.tsx
export function POMCloudLayer({ 
  radius, 
  texture, 
  pomSteps = 16,
  useVolumeScattering = true
}: POMCloudLayerProps) {
  const material = useMemo(() => new THREE.ShaderMaterial({
    uniforms: {
      map: { value: texture },
      lightDir: { value: new THREE.Vector3() },
      pomSteps: { value: pomSteps },
      heightScale: { value: 0.5 },
      volumeDensity: { value: 0.3 },
      scatteringStrength: { value: 0.5 },
      scatteringG: { value: 0.3 }, // 统一相位函数参数
      // 评审建议：TAA和历史复用
      frameIndex: { value: 0 },
      previousFrame: { value: null },
      jitterOffset: { value: new THREE.Vector2() }
    },
    vertexShader: `
      varying vec2 vUv;
      varying vec3 vViewDir;
      varying vec3 vNormal;
      varying vec3 vWorldPos;
      
      void main() {
        vUv = uv;
        vNormal = normal;
        
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vViewDir = normalize(mvPosition.xyz);
        vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
        
        gl_Position = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader: `
      uniform sampler2D map;
      uniform vec3 lightDir;
      uniform int pomSteps;
      uniform float heightScale;
      uniform float volumeDensity;
      uniform float scatteringStrength;
      uniform float scatteringG;
      uniform int frameIndex;
      uniform sampler2D previousFrame;
      uniform vec2 jitterOffset;
      
      varying vec2 vUv;
      varying vec3 vViewDir;
      varying vec3 vNormal;
      varying vec3 vWorldPos;
      
      // 统一的Henyey-Greenstein相位函数
      float henneyGreenstein(float cosTheta, float g) {
        return (1.0 - g * g) / (4.0 * 3.14159 * pow(1.0 + g * g - 2.0 * g * cosTheta, 1.5));
      }
      
      // 蓝噪声抖动
      float blueNoise(vec2 uv) {
        return fract(sin(dot(uv * 100.0, vec2(12.9898, 78.233))) * 43758.5453);
      }
      
      // POM步进函数（评审建议：低步数，辅助自遮蔽）
      vec2 parallaxMapping(vec2 uv, vec3 viewDir) {
        float height = texture2D(map, uv).r * heightScale;
        vec2 parallaxOffset = viewDir.xy * height / viewDir.z;
        
        // 添加蓝噪声抖动
        float noise = blueNoise(uv + jitterOffset);
        parallaxOffset += (noise - 0.5) * 0.001;
        
        return uv + parallaxOffset;
      }
      
      // 体积散射计算（评审建议：简化射线步进）
      vec3 calculateVolumeScattering(vec3 color, vec3 lightDir, vec3 normal, vec3 worldPos) {
        // 简化的单次散射
        float cosTheta = dot(normal, normalize(lightDir));
        float phase = henneyGreenstein(cosTheta, scatteringG);
        
        // 基于深度的密度变化
        float depth = texture2D(map, vUv).r;
        float density = 1.0 - smoothstep(0.0, 1.0, depth);
        
        // 散射颜色混合
        vec3 scatteredColor = mix(color, vec3(1.0), phase * scatteringStrength * density);
        return scatteredColor;
      }
      
      // TAA历史复用
      vec3 temporalAA(vec3 currentColor, vec2 uv) {
        vec3 previousColor = texture2D(previousFrame, uv).rgb;
        float blendFactor = 0.9; // 历史权重
        return mix(currentColor, previousColor, blendFactor);
      }
      
      void main() {
        vec2 uv = vUv;
        
        // POM视差映射（评审建议：低步数，辅助自遮蔽）
        vec2 pomUV = parallaxMapping(uv, vViewDir);
        vec3 color = texture2D(map, pomUV).rgb;
        
        // 体积散射（评审建议：体积优先）
        if (useVolumeScattering) {
          color = calculateVolumeScattering(color, lightDir, vNormal, vWorldPos);
        }
        
        // TAA抗闪烁（评审建议）
        if (frameIndex > 0) {
          color = temporalAA(color, uv);
        }
        
        gl_FragColor = vec4(color, 1.0);
      }
    `,
    transparent: true,
    depthTest: true,
    depthWrite: false
  }), [texture, pomSteps, useVolumeScattering]);
  
  return (
    <mesh>
      <sphereGeometry args={[radius, 128, 64]} />
      <primitive object={material} />
    </mesh>
  );
}
```

#### 3.3 体积散射效果
```typescript
// 体积散射着色器函数
const volumeScatteringShader = `
  // 体积散射计算
  vec3 calculateVolumeScattering(vec3 color, vec3 lightDir, vec3 normal, float density) {
    // 简单的体积散射模型
    float scattering = pow(max(0.0, dot(normal, lightDir)), 0.5);
    
    // 密度影响
    scattering *= density;
    
    // 散射颜色混合
    vec3 scatteredColor = mix(color, vec3(1.0), scattering * 0.3);
    
    return scatteredColor;
  }
  
  // 体积密度采样
  float sampleVolumeDensity(vec2 uv, float depth) {
    // 基于深度的密度变化
    float density = 1.0 - smoothstep(0.0, 1.0, depth);
    
    // 添加噪声变化
    float noise = fract(sin(dot(uv * 100.0, vec2(12.9898, 78.233))) * 43758.5453);
    density *= (0.8 + 0.4 * noise);
    
    return density;
  }
`;
```

### 验收标准（评审优化版）
- [ ] 近景场景有强烈的体积感
- [ ] 12层云层渲染正常
- [ ] POM视差效果明显（低步数，辅助自遮蔽）
- [ ] 体积散射增加真实感（体积优先，POM辅助）
- [ ] 性能保持在35+ FPS（p95 ≤ 28ms）
- [ ] 统一相位函数，与全景场景光照一致
- [ ] TAA抗闪烁效果良好
- [ ] 蓝噪声抖动 + 历史复用稳定
- [ ] 体积分辨率自适应（1/2或2/3分辨率）
- [ ] 掠视角无断层，仰视云底无伪影

---

## 第四阶段：性能优化与系统集成（2-3天）

### 目标
- 优化整体性能
- 完善LOD系统
- 添加性能监控
- 系统集成测试

### 任务清单

#### 4.1 性能优化
```typescript
// 性能优化策略
const optimizePerformance = (sceneType: string) => {
  if (sceneType === 'panorama') {
    return {
      // 全景场景优化
      geometryDetail: { segments: 64, rings: 32 },
      textureResolution: '4k',
      shaderOptimizations: {
        reduceSampling: true,
        simplifyCalculations: true,
        useLowPrecision: true
      },
      renderOptimizations: {
        frustumCulling: true,
        occlusionCulling: false,
        instancing: false
      }
    };
  } else {
    return {
      // 近景场景优化
      geometryDetail: { segments: 128, rings: 64 },
      textureResolution: '8k',
      shaderOptimizations: {
        reduceSampling: false,
        simplifyCalculations: false,
        useLowPrecision: false
      },
      renderOptimizations: {
        frustumCulling: true,
        occlusionCulling: true,
        instancing: true
      }
    };
  }
};
```

#### 4.2 动态LOD系统
```typescript
// 基于性能的自动降级
const getPerformanceLevel = () => {
  const fps = perfMonitor.getStats().fps;
  if (fps < 30) return 'low';
  if (fps < 45) return 'medium';
  return 'high';
};

// 动态调整策略
const adjustStrategy = (strategy: RenderingStrategy, performance: string) => {
  if (performance === 'low') {
    return {
      ...strategy,
      layers: Math.max(3, Math.floor(strategy.layers * 0.5)),
      usePOM: false,
      useVolumeScattering: false
    };
  } else if (performance === 'medium') {
    return {
      ...strategy,
      layers: Math.max(6, Math.floor(strategy.layers * 0.75)),
      usePOM: strategy.usePOM,
      useVolumeScattering: false
    };
  }
  return strategy;
};
```

#### 4.3 系统集成
```typescript
// 集成到 SimpleTest.tsx
export function EnhancedCloudSystem({ 
  composition, 
  earthInfo, 
  lightDirection, 
  camera 
}: EnhancedCloudSystemProps) {
  const [sceneType, setSceneType] = useState<'panorama' | 'closeup'>('panorama');
  const [strategy, setStrategy] = useState<RenderingStrategy>(getSceneStrategy('panorama'));
  
  // 场景检测和策略调整
  useEffect(() => {
    const distance = camera.position.distanceTo(earthInfo.position);
    const height = camera.position.y - earthInfo.position.y;
    
    const newSceneType = (distance < 8 && height < 5) ? 'closeup' : 'panorama';
    const baseStrategy = getSceneStrategy(newSceneType);
    const performanceLevel = getPerformanceLevel();
    const adjustedStrategy = adjustStrategy(baseStrategy, performanceLevel);
    
    setSceneType(newSceneType);
    setStrategy(adjustedStrategy);
  }, [camera.position, earthInfo.position]);
  
  return (
    <SceneAwareCloudSystem 
      sceneType={sceneType}
      strategy={strategy}
      baseRadius={earthInfo.size}
      texture={earthClouds}
      lightDirection={lightDirection}
      composition={composition}
    />
  );
}
```

### 验收标准
- [ ] 性能优化完成
- [ ] LOD系统自动调整
- [ ] 性能监控完善
- [ ] 系统集成无冲突
- [ ] 全景场景：60+ FPS
- [ ] 近景场景：35+ FPS

---

## 参数配置

### 新增参数
```typescript
// 添加到 SimpleComposition.ts
export interface SimpleComposition {
  // 场景感知控制
  cloudSceneAware: boolean;          // 启用场景感知，默认true
  cloudPanoramaLayers: number;       // 全景场景层数，默认3
  cloudCloseupLayers: number;        // 近景场景层数，默认12
  cloudSceneTransitionDistance: number; // 场景切换距离，默认8
  
  // 全景场景参数
  cloudPanoramaThickness: number;    // 全景厚度倍数，默认1.0
  cloudPanoramaThicknessLayers: number; // 全景厚度模拟层数，默认8
  cloudPanoramaThicknessVariation: number; // 全景厚度变化，默认0.3
  
  // 近景场景参数
  cloudCloseupUsePOM: boolean;       // 近景启用POM，默认true
  cloudCloseupPOMSteps: number;      // POM步数，默认16
  cloudCloseupUseVolumeScattering: boolean; // 近景启用体积散射，默认true
  cloudCloseupVolumeDensity: number; // 体积密度，默认0.3
  cloudCloseupScatteringStrength: number; // 散射强度，默认0.5
  
  // 性能控制
  cloudLODEnabled: boolean;        // 启用LOD，默认true
  cloudPerformanceMode: 'low' | 'medium' | 'high' | 'auto'; // 性能模式
}
```

### 默认值
```typescript
export const DEFAULT_SIMPLE_COMPOSITION: SimpleComposition = {
  // ... 现有参数
  
  // 场景感知控制
  cloudSceneAware: true,
  cloudPanoramaLayers: 3,
  cloudCloseupLayers: 12,
  cloudSceneTransitionDistance: 8,
  
  // 全景场景参数
  cloudPanoramaThickness: 1.0,
  cloudPanoramaThicknessLayers: 8,
  cloudPanoramaThicknessVariation: 0.3,
  
  // 近景场景参数
  cloudCloseupUsePOM: true,
  cloudCloseupPOMSteps: 16,
  cloudCloseupUseVolumeScattering: true,
  cloudCloseupVolumeDensity: 0.3,
  cloudCloseupScatteringStrength: 0.5,
  
  // 性能控制
  cloudLODEnabled: true,
  cloudPerformanceMode: 'auto'
};
```

---

## UI控制面板

### 场景感知控制
```typescript
// 添加到 SimpleTest.tsx
<div className="section">
  <h3>云层场景感知控制</h3>
  
  <div className="row">
    <label className="checkbox">
      <input type="checkbox" checked={cloudSceneAware}
             onChange={(e) => setCloudSceneAware(e.target.checked)} />
      启用场景感知渲染
    </label>
  </div>
  
  <div className="row">
    <label className="label">场景切换距离: {cloudSceneTransitionDistance.toFixed(1)}km</label>
    <input className="input" type="range" min={5} max={15} step={0.5}
           value={cloudSceneTransitionDistance}
           onChange={(e) => setCloudSceneTransitionDistance(parseFloat(e.target.value))} />
  </div>
</div>

<div className="section">
  <h3>全景场景参数</h3>
  
  <div className="row">
    <label className="label">全景层数: {cloudPanoramaLayers}</label>
    <input className="input" type="range" min={3} max={6} step={1}
           value={cloudPanoramaLayers}
           onChange={(e) => setCloudPanoramaLayers(parseInt(e.target.value))} />
  </div>
  
  <div className="row">
    <label className="label">全景厚度: {cloudPanoramaThickness.toFixed(2)}</label>
    <input className="input" type="range" min={0.5} max={2.0} step={0.1}
           value={cloudPanoramaThickness}
           onChange={(e) => setCloudPanoramaThickness(parseFloat(e.target.value))} />
  </div>
  
  <div className="row">
    <label className="label">厚度模拟层数: {cloudPanoramaThicknessLayers}</label>
    <input className="input" type="range" min={4} max={12} step={1}
           value={cloudPanoramaThicknessLayers}
           onChange={(e) => setCloudPanoramaThicknessLayers(parseInt(e.target.value))} />
  </div>
</div>

<div className="section">
  <h3>近景场景参数</h3>
  
  <div className="row">
    <label className="label">近景层数: {cloudCloseupLayers}</label>
    <input className="input" type="range" min={8} max={16} step={1}
           value={cloudCloseupLayers}
           onChange={(e) => setCloudCloseupLayers(parseInt(e.target.value))} />
  </div>
  
  <div className="row">
    <label className="checkbox">
      <input type="checkbox" checked={cloudCloseupUsePOM}
             onChange={(e) => setCloudCloseupUsePOM(e.target.checked)} />
      启用POM视差映射
    </label>
  </div>
  
  <div className="row">
    <label className="label">POM步数: {cloudCloseupPOMSteps}</label>
    <input className="input" type="range" min={8} max={32} step={1}
           value={cloudCloseupPOMSteps}
           onChange={(e) => setCloudCloseupPOMSteps(parseInt(e.target.value))} />
  </div>
  
  <div className="row">
    <label className="checkbox">
      <input type="checkbox" checked={cloudCloseupUseVolumeScattering}
             onChange={(e) => setCloudCloseupUseVolumeScattering(e.target.checked)} />
      启用体积散射
    </label>
  </div>
  
  <div className="row">
    <label className="label">体积密度: {cloudCloseupVolumeDensity.toFixed(2)}</label>
    <input className="input" type="range" min={0.1} max={0.8} step={0.1}
           value={cloudCloseupVolumeDensity}
           onChange={(e) => setCloudCloseupVolumeDensity(parseFloat(e.target.value))} />
  </div>
</div>
```

---

## 性能指标

### 目标性能
- **全景场景（>8km）**：60+ FPS，3层基础 + 着色器厚度模拟
- **近景场景（<8km）**：35+ FPS，12层真实 + POM + 体积散射

### 内存使用
- **全景场景**：增长 < 20%
- **近景场景**：增长 < 60%
- **平均增长**：< 40%

### 加载时间
- **全景场景**：增长 < 10%
- **近景场景**：增长 < 30%
- **平均增长**：< 20%

---

## 实施时间线

| 阶段 | 时间 | 主要任务 | 里程碑 |
|------|------|----------|--------|
| 第1-2天 | 场景感知系统 | 场景检测、基础双场景渲染 | 场景感知完成 |
| 第3-5天 | 全景着色器厚度 | 着色器厚度模拟、性能优化 | 全景厚度感完成 |
| 第6-9天 | 近景真实多层 | 12层渲染、POM、体积散射 | 近景体积感完成 |
| 第10-12天 | 性能优化集成 | LOD、监控、系统集成 | 生产就绪 |

---

## 风险评估

### 低风险
- **场景感知系统**：基于现有相机系统，技术风险低
- **全景着色器厚度**：扩展现有着色器，实现简单
- **参数控制**：添加UI控制，实现简单

### 中风险
- **近景多层渲染**：12层渲染可能影响性能
- **POM实现**：视差映射技术门槛中等
- **场景切换**：需要平滑过渡，避免突兀

### 高风险
- **性能影响**：近景场景可能影响帧率
- **内存使用**：增加GPU内存压力
- **系统集成**：与现有系统可能冲突

---

## 成功指标（评审优化版）

### 功能完整性
- [ ] 场景感知系统正常工作（带滞回逻辑）
- [ ] 全景场景有明显的厚度感（无掠视角伪影）
- [ ] 近景场景有强烈的体积感（体积优先，POM辅助）
- [ ] 场景切换平滑无突兀（0.5秒过渡，参数插值）
- [ ] POM视差效果明显（低步数，辅助自遮蔽）
- [ ] 体积散射增加真实感（统一相位函数）

### 性能指标（评审标准）
- [ ] 全景场景：60+ FPS（p95 ≤ 16.6ms）
- [ ] 近景场景：35+ FPS（p95 ≤ 28ms）
- [ ] 内存增长 < 40%
- [ ] 加载时间增长 < 20%
- [ ] 场景切换延迟 < 100ms
- [ ] 切换期间帧时峰值 ≤ 1.5×稳态

### 渲染一致性（评审重点）
- [ ] 同一太阳高度角下，远景与近景平均亮度差 < 10%
- [ ] 边缘厚度主观评分一致
- [ ] 掠视角稳态：地平线 ±10° 区域无明显拉丝/拼接
- [ ] 近景在仰视云底时无明显断层
- [ ] 来回跨阈值10次，肉眼无亮度/厚度突变

### 用户体验
- [ ] UI控制面板完善
- [ ] 参数调整实时生效
- [ ] 性能监控可视化
- [ ] 与现有系统无缝集成
- [ ] 场景切换自然流畅
- [ ] 抗闪烁效果良好（TAA + 蓝噪声）

---

## 结论

这个v3.1方案专门针对**双场景需求**设计，通过**场景感知混合渲染**策略，既能在全景场景保持高性能，又能在近景场景提供强烈的体积感。

**v3.1核心改进**（基于专业评审）：
- **渲染一致性**：统一相位函数、光照强度、颜色映射
- **切换稳定性**：滞回逻辑、过渡插值、平滑切换
- **性能预算**：明确的帧时预算和自适应降级策略
- **抗闪烁技术**：蓝噪声抖动 + TAA + 历史复用
- **掠视角优化**：各向异性偏移、半分辨率渲染

**核心优势**：
- **场景感知**：自动检测场景类型，智能调整渲染策略
- **性能平衡**：全景60+ FPS（p95≤16.6ms），近景35+ FPS（p95≤28ms）
- **效果显著**：全景有明显厚度感，近景有强烈体积感
- **平滑过渡**：场景切换自然流畅（0.5秒过渡）
- **渲染一致**：远景与近景平均亮度差<10%

**推荐优先级**：高
**实施难度**：中等
**预期效果**：显著提升双场景的云层真实感
**风险控制**：可选择性启用各阶段功能

### 下一步行动
1. 立即开始第一阶段：实现场景感知系统（带滞回逻辑）
2. 添加场景检测和基础双场景渲染
3. 实现统一相位函数和光照一致性
4. 测试场景切换的平滑性和渲染一致性
5. 根据效果决定是否继续后续阶段
