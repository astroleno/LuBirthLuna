方法一：直接屏幕空间渲染（推荐）

  原理：将月球直接渲染在屏幕空间，不受3D场景相机影响

  实现方式：
  - 使用HTML/CSS overlay，将月球作为绝对定位的元素
  - 或者使用Three.js的CSS2D/CSS3D渲染器
  - 或者使用正交相机专门渲染月球到固定屏幕位置

  优点：
  - 完全独立于主场景相机
  - 位置固定，不会随相机移动而改变
  - 性能开销小

  缺点：
  - 需要手动处理月球的缩放和旋转
  - 与3D场景的深度关系需要手动处理

  方法二：相机跟随机制

  原理：让月球始终跟随主相机移动，保持相对位置

  实现方式：
  - 在每帧更新中，将月球位置设置为相机位置 + 固定偏移
  - 使用相机的up和right向量计算正确的世界坐标

  优点：
  - 月球仍在3D空间中，可以正确参与光照和阴影
  - 实现相对简单

  缺点：
  - 月球会随相机移动而移动（但相对位置固定）
  - 可能会与场景其他物体产生遮挡关系

  方法三：双渲染层系统

  原理：使用两个独立的渲染层，主场景渲染地球，副场景渲染月球

  实现方式：
  - 主相机渲染地球和背景（layer 0）
  - 副相机（正交相机）只渲染月球（layer 1）
  - 将副相机的渲染结果合成到主画面上

  优点：
  - 月球渲染完全独立，不受主相机影响
  - 可以单独控制月球的显示效果

  缺点：
  - 实现复杂，需要管理多个相机
  - 性能开销较大

  方法四：世界坐标锁定

  原理：将月球固定在世界坐标的某个位置，但根据相机位置动态调整

  实现方式：
  - 计算相机到屏幕固定位置的方向向量
  - 将月球放置在该方向上的固定距离处
  - 每帧更新月球位置以跟随相机

  优点：
  - 月球在3D空间中，可以正确参与光照计算
  - 位置看起来固定在屏幕上

  缺点：
  - 计算相对复杂
  - 可能会产生视差效果

  推荐方案

  对于你的需求，我推荐方法一：直接屏幕空间渲染，因为：

  1. 最简单直接：不需要复杂的3D计算
  2. 最稳定：月球位置完全固定，不受任何3D变换影响
  3. 性能最好：不需要额外的3D渲染开销
  4. 最灵活：可以随意调整月球的大小、位置和样式

  具体实现可以是：
  - 使用一个div元素，绝对定位在屏幕上
  - 用Three.js渲染月球到canvas或者使用CSS 3D变换
  - 或者直接使用月球图片作为背景