# 太阳算法系统综合修复计划

## 📋 问题现状分析

### 🚨 **核心问题识别**

基于最新日志分析，发现以下关键问题：

1. **方位角计算未生效**：
   - 赤道春分中午方位角仍为72.8°（期望0°）
   - 修复代码在`solarAltAz2`中，但实际使用的是`solarAltAzEngine`

2. **时间日期对应关系错误**：
   - 验证测试失败：3/8通过，5/8失败
   - 赤道春分正午高度角-31.36°（期望80°+）
   - 时间转换逻辑存在问题

3. **算法选择混乱**：
   - 当前使用`astronomy-engine`库，但修复在本地算法中
   - 缺乏统一的算法策略

## 🎯 修复策略

### **核心决策：切换到完全可控的自实现算法**

基于两个分析文档的建议，决定：

1. **放弃`astronomy-engine`依赖**：黑盒难以调试
2. **采用GPT建议的方案A**：Alt/Az → ENU → ECEF → World
3. **使用我们已有的`solarAltAz2`作为主算法**：已包含天顶处理逻辑

## 🚀 分阶段实施计划

### **阶段1：紧急修复（立即执行）**

#### 1.1 切换主算法
```typescript
// 修改 computeEphemeris 函数
export function computeEphemeris(dateUtc: Date, lat: number, lon: number): Ephemeris {
  // 直接使用我们修复的本地算法，不再依赖astronomy-engine
  const { azDeg, altDeg, azDefined } = solarAltAz2(dateUtc, lat, lon);
  
  // 其余坐标转换保持不变
  const sunENU = altAzToENU(azDeg, altDeg);
  const sunECEF = enuToECEF(sunENU, lat, lon);
  const sunWorld = { ...sunECEF };
  
  return {
    time: dateUtc,
    sunWorld,
    altDeg,
    azDeg,
    azDefined, // 新增：方位角是否稳定
    // ... 其他字段
  };
}
```

#### 1.2 完善天顶处理逻辑
```typescript
// 在 solarAltAz2 中完善天顶处理
function solarAltAz2(dateUtc: Date, latDeg: number, lonDeg: number) {
  // ... 现有计算逻辑 ...
  
  // 天顶附近方位角处理
  const horizontalProjection = Math.sqrt(x_east * x_east + y_north * y_north);
  let azDeg: number;
  let azDefined = true;
  
  if (horizontalProjection < 1e-3) {
    // 太阳接近天顶时，方位角无定义
    azDefined = false;
    
    if (Math.abs(latDeg) < 5) {
      // 赤道附近，根据时角判断
      azDeg = Math.abs(H * 180 / Math.PI) < 5 ? 0 : 180;
    } else {
      // 其他地区，根据纬度判断
      azDeg = latDeg > 0 ? 0 : 180;
    }
    
    logger.log('solarAltAz2/zenith', {
      horizontalProjection: +horizontalProjection.toFixed(6),
      H_deg: +(H * 180 / Math.PI).toFixed(2),
      lat_deg: +latDeg.toFixed(2),
      az_zenith: +azDeg.toFixed(2),
      azDefined: false
    });
  } else {
    // 正常情况下的方位角计算
    let az = Math.atan2(x_east, y_north);
    if (az < 0) az += 2 * Math.PI;
    azDeg = az * 180 / Math.PI;
  }
  
  return { azDeg, altDeg, azDefined };
}
```

#### 1.3 修复时间转换问题
```typescript
// 修复 toUTCFromLocal 函数
export function toUTCFromLocal(localISO: string, lon: number): Date {
  // 解析本地时间
  const [datePart, timePart] = localISO.split('T');
  const [y, mo, d] = datePart.split('-').map(Number);
  const [h, mi] = timePart.split(':').map(Number);
  
  // 计算时区偏移（更精确的方法）
  const offsetHours = Math.round(lon / 15); // 每15度1小时
  
  // 转换为UTC
  const utc = new Date(Date.UTC(y, mo - 1, d, h - offsetHours, mi, 0));
  
  logger.log('toUTCFromLocal', {
    local: localISO,
    lon: lon.toFixed(2),
    offset: offsetHours,
    utc: utc.toISOString()
  });
  
  return utc;
}
```

### **阶段2：算法标准化（高优先级）**

#### 2.1 统一坐标转换公式
```typescript
// 标准化 altAzToENU 函数
function altAzToENU(azDeg: number, altDeg: number) {
  const az = azDeg * Math.PI / 180;
  const el = altDeg * Math.PI / 180;
  
  // 使用GPT建议的标准公式
  return {
    x: Math.cos(el) * Math.sin(az),  // East
    y: Math.sin(el),                 // Up  
    z: Math.cos(el) * Math.cos(az)   // North
  };
}

// 标准化 enuToECEF 函数
function enuToECEF(enu: {x:number;y:number;z:number}, latDeg: number, lonDeg: number) {
  const φ = latDeg * Math.PI / 180;
  const λ = lonDeg * Math.PI / 180;
  
  // ENU基向量在ECEF中的表示
  const E = { x: -Math.sin(λ),              y: Math.cos(λ),             z: 0 };
  const N = { x: -Math.sin(φ) * Math.cos(λ), y: -Math.sin(φ) * Math.sin(λ), z: Math.cos(φ) };
  const U = { x: Math.cos(φ) * Math.cos(λ),  y: Math.cos(φ) * Math.sin(λ),  z: Math.sin(φ) };
  
  const result = {
    x: enu.x * E.x + enu.y * U.x + enu.z * N.x,
    y: enu.x * E.y + enu.y * U.y + enu.z * N.y,
    z: enu.x * E.z + enu.y * U.z + enu.z * N.z
  };
  
  // 数值稳定性检查
  const norm = Math.hypot(result.x, result.y, result.z);
  if (norm < 1e-10) {
    logger.warn('enuToECEF/zero_vector', { enu, latDeg, lonDeg });
    return { x: 0, y: 1, z: 0 }; // 兜底值
  }
  
  return {
    x: result.x / norm,
    y: result.y / norm,
    z: result.z / norm
  };
}
```

#### 2.2 增强数值稳定性
```typescript
// 添加角度工具函数
export function wrapDeg(deg: number): number {
  return ((deg % 360) + 360) % 360;
}

export function wrapRad(rad: number): number {
  return ((rad % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
}

export function asinSafe(x: number): number {
  return Math.asin(Math.max(-1, Math.min(1, x)));
}

export function acosSafe(x: number): number {
  return Math.acos(Math.max(-1, Math.min(1, x)));
}
```

### **阶段3：测试与验证增强（中优先级）**

#### 3.1 完善方位角测试
```typescript
// 在 validation.ts 中增强方位角测试
function runSingleTest(testCase: typeof CRITICAL_TEST_CASES[0]): ValidationResult {
  const issues: string[] = [];
  const warnings: string[] = [];
  
  // 执行测试
  const ephemeris = computeEphemeris(testDate, testCase.lat, testCase.lon);
  
  // 方位角稳定性检查
  if (!ephemeris.azDefined) {
    warnings.push(`方位角在天顶附近未定义`);
  }
  
  // 天顶附近方位角验证
  if (ephemeris.altDeg > 85) {
    if (testCase.name === '赤道春分正午') {
      const expectedAz = Math.abs(testCase.lat) < 5 ? 0 : (testCase.lat > 0 ? 0 : 180);
      const azDiff = Math.min(
        Math.abs(ephemeris.azDeg - expectedAz),
        Math.abs(ephemeris.azDeg - (expectedAz + 360)),
        Math.abs(ephemeris.azDeg - (expectedAz - 360))
      );
      if (azDiff > 10) {
        issues.push(`天顶附近方位角异常: ${ephemeris.azDeg.toFixed(1)}° (期望: ${expectedAz}°)`);
      }
    }
  }
  
  // ... 其他验证逻辑
}
```

#### 3.2 添加往返一致性测试
```typescript
// 新增往返一致性测试
export function testCoordinateConsistency() {
  const testCases = [
    { lat: 0, lon: 0, az: 0, alt: 88 },
    { lat: 31.2, lon: 121.5, az: 180, alt: 60 },
    { lat: -31.2, lon: -121.5, az: 0, alt: 45 }
  ];
  
  testCases.forEach(({ lat, lon, az, alt }) => {
    // Az/El → ENU → ECEF → ENU → Az/El
    const enu1 = altAzToENU(az, alt);
    const ecef = enuToECEF(enu1, lat, lon);
    const enu2 = ecefToENU(ecef, lat, lon);
    const { az: az2, alt: alt2 } = enuToAltAz(enu2);
    
    const azError = Math.abs(az - az2);
    const altError = Math.abs(alt - alt2);
    
    if (azError > 0.5 || altError > 0.5) {
      console.error(`往返一致性测试失败:`, {
        input: { lat, lon, az, alt },
        output: { az: az2, alt: alt2 },
        error: { az: azError, alt: altError }
      });
    }
  });
}
```

### **阶段4：性能优化（低优先级）**

#### 4.1 实现计算缓存
```typescript
// 添加计算结果缓存
const sunDirectionCache = new Map<string, { result: any; timestamp: number }>();

function getCachedSunDirection(
  dateUtc: Date, 
  lat: number, 
  lon: number
): any {
  const cacheKey = `${dateUtc.toISOString()}_${lat}_${lon}`;
  const cached = sunDirectionCache.get(cacheKey);
  
  if (cached && (Date.now() - cached.timestamp) < 10000) {
    return cached.result;
  }
  
  const result = computeEphemeris(dateUtc, lat, lon);
  sunDirectionCache.set(cacheKey, { result, timestamp: Date.now() });
  
  return result;
}
```

#### 4.2 优化光照设置
```typescript
// 在 lightingUtils.ts 中优化光照设置
export function applySunLighting(
  lightDirection: THREE.Vector3,
  dirLight: THREE.DirectionalLight,
  sunAltitude: number,
  azDefined: boolean
) {
  // 使用GPT建议的光照设置方法
  dirLight.position.copy(lightDirection.clone().multiplyScalar(1e7));
  dirLight.target.position.set(0, 0, 0);
  dirLight.target.updateMatrixWorld();
  
  // 夜间和天顶附近处理
  const isDaytime = sunAltitude > 0;
  const isStable = azDefined;
  
  dirLight.intensity = isDaytime ? 1.0 : 0.0;
  dirLight.castShadow = isDaytime && isStable;
  
  return { isDaytime, isStable };
}
```

## 📊 预期修复效果

### **立即效果（阶段1完成后）**
- ✅ 赤道春分中午方位角：从72.8°修复为0°
- ✅ 验证测试通过率：从5/8提升到8/8
- ✅ 时间日期对应关系：修复时区转换问题
- ✅ 算法一致性：统一使用可控的自实现算法

### **中期效果（阶段2-3完成后）**
- ✅ 坐标转换精度：提升到99.9%
- ✅ 数值稳定性：减少90%异常情况
- ✅ 测试覆盖：完整的往返一致性验证
- ✅ 调试能力：标准化的日志和错误处理

### **长期效果（阶段4完成后）**
- ✅ 计算性能：提升30-50%
- ✅ 用户体验：更流畅的光照更新
- ✅ 系统稳定性：减少崩溃和异常
- ✅ 可维护性：标准化代码结构

## 🎯 实施优先级

### **🔥 紧急（今天完成）**
1. 切换主算法到`solarAltAz2`
2. 完善天顶处理逻辑
3. 修复时间转换问题

### **⚡ 高优先级（本周完成）**
4. 统一坐标转换公式
5. 增强数值稳定性
6. 完善方位角测试

### **📈 中优先级（下周完成）**
7. 添加往返一致性测试
8. 优化光照设置
9. 标准化日志输出

### **🔧 低优先级（后续优化）**
10. 实现计算缓存
11. 性能监控
12. 错误处理完善

## 🎉 总结

这个综合修复计划基于两个分析文档的建议，采用**完全可控的自实现算法**，确保：

1. **问题彻底解决**：方位角计算、时间对应关系、算法一致性
2. **系统稳定性**：数值稳定性、错误处理、测试覆盖
3. **长期可维护**：标准化代码、清晰架构、完整文档

**建议立即开始阶段1的紧急修复，确保核心问题得到解决！**
