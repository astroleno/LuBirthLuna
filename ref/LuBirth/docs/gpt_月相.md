结论先说：你看到“左 → 满 → 左”的顺序，根因是「相位角 a 的取值没有带上盈/亏方向信息（被折叠在 0–π/180° 之间）」与「把 R 分量写成了固定取负」这两件事叠加造成的：

* 因为 a 实际只在 0–π 之间变化，sin(a) 始终 ≥ 0，配合你现在的太阳方向公式里对 R 分量固定取负，导致上弦和下弦两头的“水平分量”永远朝同一侧，于是两边都亮在左边，形成“左—满—左”。&#x20;

下面按链路完整梳理一遍，指出具体“拐弯点”在哪儿发生了方向丢失/翻转：

# 1) 数据源：a 的定义与取值区间

* 你在 `getMoonPhase` 里用的是 `Elongation(Body.Moon, time)` 得到的角度，并把它当作“0–360° 的完整月相角”（0°=新月，90°=上弦，180°=满月，270°=下弦）。代码注释也是这么写的。
* 但实际情况很可能是：该函数返回的“伸距/相离角”是 **0–180°** 的夹角（天文库里常见的定义），并不会自带盈亏的符号或 180–360° 区间。你的后续“<0 加 360 / ≥360 减 360”的保护分支并不能把 0–180° 自动扩展成 0–360°，所以 a 在整个月相循环里被“对折”在 0–π。这样一来，“满月前的 90°”和“满月后的 90°”都会变成同一个数值 90°，盈亏方向信息完全丢失。

直观后果：

* 在“上弦”和“下弦”两个时刻，你拿到的 a 都 ≈ 90°（而不是 90°、270° 一对有符号的一正一负正弦）。

# 2) 观测系基向量的构建（没问题）

* 在 `Moon` 组件里，你基于相机与月球构了正交基：

  * F = 归一化(cam − moon)（从月球指向相机）
  * U = 相机 up 去投影到垂直 F 的平面
  * R = U × F（右手系，R 指向“相机右”）
    这个基是自洽的，R 的方向也与“相机画面右侧”一致。

# 3) 虚拟太阳方向的映射公式（这里发生了“水平翻转+方向丢失”的叠加）

* 你把“相位角 a（设想为 0–2π）”映射为：

  ```
  S = -sin(a)·R  +  -cos(a)·F
  ```

  你的注释期望：a=0° 新月 → S≈-F；a=90° 上弦 → S≈-R；a=180° 满月 → S≈F；a=270° 下弦 → S≈R。
* 若 a 真能到 270°，这个公式给“上弦在左、下弦在右”的一左一右（其实与北半球直觉相反，见下一点）。但由于第 1 步 a 被折叠在 0–π，**运行时根本不会出现 270°**：

  * 上弦：a≈90° → S≈-R（左侧光）
  * 下弦：折回后仍是 a≈90° → 还是 S≈-R（还是左侧光）
  * 满月：a≈180° → S≈+F（满）
    ——于是你就看到了“左 → 满 → 左”。

另外，再看“北半球习惯（上弦右、下弦左）”这一点：

* 以你定义的基（R 为相机右）为准，想要 **“上弦右、下弦左”**，在 a 真·0–2π 的前提下，映射更自然的是：

  ```
  S 期望 ≈  sin(a)·R  −  cos(a)·F
  ```

  这样：

  * a=0°（新）：S≈−F
  * a=90°（上弦）：S≈+R（右）
  * a=180°（满）：S≈+F
  * a=270°（下弦）：S≈−R（左）
* 你当前公式把 R 项取了负号，等价于把“左右”镜像了一次，所以就算以后 a 真的有了 270°，你也会得到“上弦左、下弦右”的相反视觉。现在再叠加“a 被折叠到 0–π”的问题，就成了“两头都左”。

# 4) 着色器与运行时更新（会忠实放大上述映射的结果）

* 片元着色里用 `dot(normal, lightDir)` 做了朗伯漫反射，`lightDir` 来自你每帧更新的 `sunDirWorldForShading`；而这个向量在 `useFrame` 分支里也用的是同一套 `-sin(a)·R - cos(a)·F` 的构造逻辑（且 a 仍旧来自上面的相位角）。因此一旦第 1/3 步定了方向，渲染就稳定产出“左—满—左”。

# 5) 为什么你在控制台的“270°测试”看起来对，但实景却不对？

* 你有个全局 `testMoonPhaseFormula(0/90/180/270, R, F)` 的打印，这只是“代入固定角度”的单元测试；当你代入 270° 时，当然会打印出“右侧”。但**运行时真正用来着色的 a** 是来自第 1 步的数据管线，而它从未到达 270°（被折叠在 0–180°），所以现实渲染不会出现“右侧”那一半。

# 6) 快速复核清单（不改代码也能定位到问题）

1. 打印 `getMoonPhase` 返回的 `phaseAngleRad`，连续跨越满月前后三天，确认角度是否跨过 180° 继续增至 270°、300°，还是在 180° 后“折回到 179°、178°…”。若是后者，即证实 a 被折叠在 0–π。
2. 在相同时间点，记录 `sin(a)` 的符号。若满月前后两天 `sin(a)` 都 > 0，则从三角函数层面已说明“水平分量不会换边”。
3. 在 `useMemo` 里打印构造出的 `R` 向量与 `sunDirection`，核对“上弦/下弦”两个时刻的 `sunDirection` 的 R 分量符号是否相同（应当一正一负，实际大概率同为负）。

# 7) 小结（不动代码的诊断结论）

* 链路中的“方向信息”在 **相位角来源** 处已经丢了半圈（只有 0–π，没有 0–2π），导致盈亏不可区分；
* 再加上“映射公式把 R 项固定取负”的水平镜像，使得两端都亮在左边；
* 于是渲染出的顺序就是你看到的“左 → 满 → 左”。
  对应代码位置：相位角的产生与使用在 `getMoonPhase` 和 `Moon` 两处。&#x20;

短答：仅靠“改正负号”不会解决。你之所以在「左—满—左 / 右—满—右」之间来回，只是把整套几何关系整体镜像了一次，但系统里真正缺的是两样东西：
1）**盈亏方向（0–360° 的有向相位）**，而不是被折叠到 0–180° 的“夹角”；
2）**明暗分界线在画面中的朝向 χ（bright-limb position angle）**，它取决于“太阳在你视野平面的投影相位”，不是一个用 `a` 随便拼 F/R 的常量映射。

你现在的约束（相机固定、月球贴图潮汐锁定并固定在屏幕某点、月相只由日期决定、不用系统光）都没有问题；问题在“把‘哪一侧发亮’这件事，简化成了 a→(±R, ±F) 的手工映射”。当 a 本身没有带“盈亏方向”，再怎么改符号，只能把同一个错误翻到另一侧。

下面把正确的几何链路从头到尾梳理一遍（不写代码，给可直接代入的量与检查点）：

# 1. 用“向量”而不是“相位角拼映射”来决定哪边亮

月面哪一边亮，等价于回答：**“太阳方向在相机视平面上的方位角是多少？”**
因此不要先入为主用 `a` 去造 `sunDir = −sin(a)·R − cos(a)·F` 这类公式；要直接用日期算出**真实的太阳方向向量 `s`** 与**月球方向向量 `m`**（地心/观察者近似皆可）。你不想引入“系统光”没关系——这里只是算两个**天体方向向量**，不会往 Three.js 灯光里塞。

* `m`：从观察点指向月球的单位向量
* `s`：从观察点指向太阳的单位向量

# 2. 构建画面坐标基底（你这部分基本是对的）

* 前向（看向月心）：`F = normalize(camPos → moonPos)`
* 画面“上”（你锁定的 up）：`U = normalize( up − (up·F)F )`（投影去掉前向分量）
* 画面“右”：`R = U × F`（右手系）

这三者定义了**屏幕平面**与“左右/上下”的方向。

# 3. 直接把太阳向量投影到屏幕平面，得到“哪侧亮”的**位置角 χ**

把 `s` 在 `{R, U, F}` 基底下分解：

* `sR = dot(s, R)`（太阳在画面右的分量）
* `sU = dot(s, U)`（太阳在画面上的分量，用来决定“终止线的倾斜”）
* `sF = dot(s, F)`（太阳相对相机的前后分量）

把 `s` 投到屏幕平面上（丢弃深度）：

* `s_screen = s − sF·F`
* 画面中的**位置角**（以“朝向观察者的反前向 −F”为 0°，逆时针到 R 为正）：
  `χ = atan2( dot(s, R), −dot(s, F) )`
  直观理解：

  * `χ ≈ 0°`：太阳在月面“你身后”方向（新月）
  * `χ ≈ +90°`：太阳在画面“右侧”（上弦右亮）
  * `χ ≈ 180°`：太阳在你“正前方”（满月）
  * `χ ≈ −90°`：太阳在画面“左侧”（下弦左亮）

> 关键：这个 χ 是“画面内的真实方位”，天然包含你锁定的相机 up、你定义的右、相机 roll 等因素；**不需要靠拍脑袋给 R/F 加正负号**。

# 4. 亮面“多少”由**伸距角 γ**（Sun–Moon 夹角）给出，亮面“哪边”由 χ 给出

* 伸距角 `γ = arccos( dot(s, m) )`，范围 0..π 即可；
* 亮面比例（照度分数）`k = (1 + cos γ)/2`；
* 但**左右**不看 `k`，而看第 3 步的 χ：

  * `χ` 在 +90° 附近 → 右亮（上弦）；
  * `χ` 在 −90° 附近 → 左亮（下弦）。

也就是说：

* **“多少亮”（圆/弦/月牙的粗细）** ← 只需要 0..π 的 γ；
* **“亮在画面哪一侧”** ← 只需要投影得到的 χ；
  两者互不替代。你之前把两件事都交给了“无符号的 a 再配固定符号的 R/F”，必然丢向。

# 5. 你会问：那“盈亏方向（waxing/waning）”在哪儿体现？

它不需要你硬造 0–360°；当时间推进时，`χ` 会从 0°→+90°→180°→−90°→0° 连续变化（在你锁定相机的设定下，也会自然绕回）。**盈亏“左右”是 χ 的符号/象限决定的**，不是来自“给 a 一会儿加负号、一会儿换成 270°”。
当然，如果你仍然想保留一个“有向相位角 ã”，可直接取：

* `ã = atan2( dot(s, R), −dot(s, F) )`（即 χ），或
* `ã = atan2( dot( s, R ), dot( s, −F ) )` 的等价变体。
  这就是“你真正想要的 0..2π 相位”，它是**从向量几何反推出来**的，而不是凭空规定。

# 6. 回到你的现象：“左—满—左 / 右—满—右”互相切换

这正好对应：

* 你用“无符号相位 a（0..π）+ 固定手工映射到（±R, ±F）”，**没有 χ**；
* 改正负号，只是把整套映射镜像一次，于是整个月都变成另一组“右—满—右”。
  要破局，必须引入第 3 步的**投影位置角 χ**（或等价地直接用 `s` 与 `{R,U,F}` 的点积来驱动着色）。

# 7. 按你当前架构的不改代码“核验清单”

1）打印一周内逐日的 `dot(s, R)` 与 `dot(s, F)`，观察 `atan2(dot(s,R), −dot(s,F))` 是否跨越 +90° 与 −90° 附近。如果它总是保持一侧（例如恒为正），说明你实际上**没有在用真实的 `s`**，而是在用 `a` 的拼接公式。
2）同一时期打印 `γ = arccos(dot(s, m))` 与亮面比例 `k = (1+cos γ)/2`，确认“圆度”是否随日期变化正常（这部分你大概率是对的）。
3）在“上弦、满月、下弦”当日，分别记录 `(sR, sU, sF)` 的符号组合，尤其是 `sR` 的符号是否在上/下弦切换。如果没有切换，你的“左/右”自然不会切换。

# 8. 和你的约束对齐

* 不用系统光：可以，`s`/`m` 只用于计算 χ 和 γ，最后把**一条定向光**（或 shader uniform）设成 `s` 即可；你现在也是在自己喂 `sunDirUniform`。
* 月球贴图潮汐锁定、固定在画面某点：可以，`R/U/F` 本来就是从相机与月心关系算出来，潮汐锁定只影响“纹理滚转”但不影响 χ 的定义。
* 月相只跟日期：可以，把 `s`/`m` 按日期（取每天 12:00 UT 之类）算一组即可；**关键是必须“真的”从日期得到向量**，不能再用“相位角→手工合成方向”的近似。

—

结论：
你遇到的问题并不是“正负号没选对”，而是**方法错位**——拿“无向相位 + 硬编码合成”去替代“真实太阳方向在画面中的投影”。只要把“哪一侧亮”的判定改为**基于 `s` 在 `{R,U,F}` 中的投影（位置角 χ）**，并把“亮多少”交给 `γ`，在你现有的 UI/相机/潮汐锁定设定下，顺序就会稳定成为“右→满→左”（或在你定义的 up/右手系下的相应常识序），不再出现“左满左/右满右”二选一的镜像困境。

