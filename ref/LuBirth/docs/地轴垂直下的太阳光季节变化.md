先把两种“设定”分开说清楚，再给你一套可直接落地的方向向量公式。

情况A：物理真实，但“地轴垂直”（无倾角）
	•	设地轴与自转轴完全垂直于赤道面（倾角=0°）。
	•	则太阳的赤纬 δ 恒为 0°（一直直射赤道），一年中不会上下摆动。
	•	结果：没有四季。白昼长度全年不变（除极少数天文微小效应），太阳方向永远在赤道面里绕一圈，只有“日夜变化”，没有“季节变化”。

如果你要“忠实物理”，那在 Three.js/Unity 里，你只需让平行光在赤道面里按一天 360° 转动即可，δ=0 不变。

情况B：你坚持“地轴垂直”，但仍想做出“四季外观”

做法是：把原本属于地轴倾角的季节摆动，转嫁到太阳平行光的方向。直白说——让光源方向自己上下摆动 ±23.44°，而不是倾斜地球。
	•	设地轴始终竖直（世界坐标 +Z 为北极，地球不倾斜）。
	•	令太阳方向的赤纬 δ(t) 随年周期在 ±ε 间正弦摆动（ε≈23.44°）。
	•	同时保留日变化（一昼夜的时角旋转）。

一个够用、实现简单的参数化如下（世界坐标系：+Z=北极，+X=经度0°经线交点，+Y 指向东经90°）：
	1.	年度相位（朴素年相位即可）

doy = 当年的第几天（1..365/366）
γ = 2π * (doy - 1) / 365.2422

	2.	季节摆动（把地轴倾角挪到光源）

ε = 23.44°（转弧度用 ε_rad = ε * π/180）
δ = ε * sin(γ)    // 赤纬，弧度

	3.	日变化（时角）

	•	取“太阳时角” H：正午 H=0；每小时转 15°。
	•	粗略做法：用一天中的小数时刻 t_day（0..1），再加一个偏置让正午对齐你想要的画面：

H = 2π * (t_day - 0.5) + H_bias

若不追求“真太阳时/均时差/经度修正”，这个就足够好看；要更真，可把 H 与经度、均时差合成。

	4.	太阳方向向量（地心-赤道坐标，指向“来自太阳的光线”）

ux =  cos(δ) * cos(H)
uy =  cos(δ) * sin(H)
uz =  sin(δ)
dir_sun = normalize([ux, uy, uz])

	5.	给渲染引擎

	•	平行光方向取 -dir_sun（光线从太阳指向地球）：
	•	Three.js：dirLight.position.set(... -dir_sun * R)，dirLight.target.position.set(0,0,0)
	•	Unity：light.transform.forward = -dir_sun;
	•	这样做的视觉效果：
	•	日变化：H 随一天旋转 → 日出/正午/日落有了。
	•	季节变化：δ 随年度上下摆动 → 正午太阳高度与昼长随季节变。

⸻

两句总括
	•	真实物理 + 地轴垂直 ⇒ δ=0°，无四季，光只在赤道面转圈。
	•	想保留四季外观 + 地轴仍垂直 ⇒ 把地轴倾角"转嫁"给平行光：让光源的赤纬 δ(t) 在 ±23.44° 之间按年正弦摆动，同时保留每天的时角旋转。

## 针对你的React Three Fiber项目的具体实现建议

### 1. 集成到现有固定太阳模式

你已经在 `lightingUtils.ts:22-27` 中实现了固定太阳模式支持，建议在此基础上扩展：

```typescript
// 在 composition 中添加季节控制参数
composition.useSeasonalVariation = true; // 启用季节变化
composition.seasonOffset = 0; // 季节偏移（0-365天）
composition.obliquity = 23.44; // 黄赤交角
```

### 2. 数学公式实现（TypeScript版本）

```typescript
// 在 lightingUtils.ts 中添加季节变化计算函数
export function calculateSeasonalSunDirection(
  dayOfYear: number,    // 1-365
  hourOfDay: number,    // 0-24
  latitude: number,     // 观测者纬度
  obliquity: number = 23.44
): THREE.Vector3 {
  // 1. 年度相位
  const gamma = 2 * Math.PI * (dayOfYear - 1) / 365.2422;
  
  // 2. 季节摆动（赤纬）
  const epsilonRad = obliquity * Math.PI / 180;
  const delta = epsilonRad * Math.sin(gamma);
  
  // 3. 日变化（时角）
  const H = 2 * Math.PI * (hourOfDay / 24 - 0.5);
  
  // 4. 太阳方向向量（地心-赤道坐标）
  const ux = Math.cos(delta) * Math.cos(H);
  const uy = Math.cos(delta) * Math.sin(H);
  const uz = Math.sin(delta);
  
  return new THREE.Vector3(ux, uy, uz).normalize();
}
```

### 3. 修改光照方向计算

在 `useLightDirection` 函数中添加季节变化支持：

```typescript
if (composition?.useFixedSun && composition?.useSeasonalVariation) {
  // 使用季节变化的固定太阳模式
  const dayOfYear = getDayOfYear(new Date());
  const hourOfDay = getHourOfDay(new Date());
  const latitude = composition.latitude || 0;
  
  const seasonalDirection = calculateSeasonalSunDirection(
    dayOfYear,
    hourOfDay,
    latitude,
    composition.obliquity || 23.44
  );
  
  return seasonalDirection;
}
```

### 4. 优势分析

**相比你现有的动态光照系统，这种方案的优势：**

1. **性能更好**：不需要复杂的天文计算，直接使用参数化公式
2. **控制更直观**：直接控制光源方向，易于调试和调整
3. **兼容现有架构**：基于你已有的固定太阳模式扩展
4. **视觉效果可控**：可以精确控制季节变化的幅度和速度

### 5. 实施步骤

1. **第一阶段**：在现有固定太阳模式基础上添加季节变化开关
2. **第二阶段**：实现数学公式计算函数
3. **第三阶段**：集成到光照方向计算中
4. **第四阶段**：添加UI控制参数（季节偏移、倾角等）

### 6. 验证建议

建议创建专门的季节变化测试用例：
- 春分：太阳应在赤道面内
- 夏至：太阳达到最大北偏
- 冬至：太阳达到最大南偏
- 检查日出日落时间随季节的变化

这种方案既保持了地轴垂直的简化设定，又能提供逼真的季节视觉效果，是你的项目的理想选择。

如果你愿意，我可以把上面的式子直接改成 Three.js/GLSL/Unity C# 的最小可用代码片段（含弧度/度转换与参数注释），方便你即贴即用。