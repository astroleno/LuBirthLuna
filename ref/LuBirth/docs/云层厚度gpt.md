如果目标是“地球表面的云层”，而且你要**能拉到近景**还显得**很有体积**，建议用“分层混合的混合式方案”，而不是只押注某一种技术。最稳的是下面这套三段式 LOD：

# 推荐路线（混合式 LOD）

1. 远景/中远景：**POM（视差遮挡映射）包球体**

* 载体：一张（或多张分片）包裹地球的球体网格。
* 着色：对云的高度贴图做 POM（8–16 步，角度越刁钻步数越多），只做视差与局部自遮挡；不改几何。
* 目的：成本最低却能在高斜视角给出“厚度/视差”的第一观感。
* 备注：用三平面（Triplanar）或经纬度分片避免两极拉伸。

2. 中景：**壳层体渲染（Shell Texturing）包薄球壳**

* 载体：在地球半径之外 +Δr 处，实例化 **N 层薄球壳**（N≈16–32；桌面可 24–32，移动端 12–16）。每层沿球面外法线偏移固定厚度 `Δr/N`。
* 着色：每层采同一张密度/高度贴图（可带 1–2 张噪声调制），把该层“是否有云/有多少云”转成 alpha 并累积混合（`transparent=true, depthWrite=false`，启用有序抖动减少条带）。
* 目的：给“云带/云墙”的体积与软边，解决单纯 POM 在中景时“像贴纸”的问题。
* 备注：仍然建议用 Triplanar，近赤道可用 UV，靠近两极自动转 Triplanar 过渡。

3. 近景/特写：**屏幕空间短程体积光线行进（Ray March）局部补丁**

* 载体：不是整颗球，而是在镜头下**局部投影出一块“体积补丁”**（例如沿相机的地表投影包围盒），或采用“球壳内局部 clipmap 瓦片”。
* 着色：对这块补丁做 8–24 次体密度采样（Beer-Lambert 透射积累）+ 4–8 次沿太阳方向的简化阴影步进。
* 目的：近距离穿透观察时给真正的体积感、软阴影、内部层理。
* 备注：只在相机附近启用；**距离/屏占比门限**外退化为壳层或 POM。配合 TAA/时间重投影抑制闪烁。

这三层在**距离与视角**上交错混合，观感连贯、性能可控：

* 屏幕空间体积只覆盖相机下方一小块区域（比如 400–800km 的地面 footprint），其余大面积天底由壳层+POM 负责。
* 视角很斜时提高 POM 步数；视角接近垂直时降低步数、把权重给壳层/体积。

---

## 关键参数与工程落地

**比例/单位**

* 假设地球半径 `R≈6371 km`，可按你的场景缩放到引擎单位。
* 云层有效厚度：`H≈1–5 km`（深对流云更厚，但全球层云/积云主导厚度在这个量级）。
* 外壳半径：`R_cloud = R + H`。壳层方案里每层偏移 `Δr = H/N`。

**POM（远景）**

* 步数：`steps = mix(8, 24, saturate(1 - |N·V|))`（斜视更多步）；Cone-step 可把平均步数减半。
* 自遮挡：用高度差近似一次阴影即可，别上真软阴影。
* 法线：保留 normal/bump 细节，POM 只负责视差与遮挡。

**壳层（中景）**

* `N = 24`（桌面）/`16`（移动）；`depthWrite=false`，双面或基于视角剔除背面。
* 透明抖动：用蓝噪（blue noise）或 Bayer 4×4 有序抖动，把密度转透明度时降低条带。
* 采样：Triplanar + 一张高频噪声做次级纹理（破坏层线感）。

**近景体积（Ray March）**

* 采样步：`8–16` 主步（密度），`4–8` 阴影步（沿光线），根据屏占比自适应。
* 边界：限制在 `[R, R+H]` 的球壳内，超界直接退出。
* 稳定化：时间重投影 + clamp 历史；或更简单些，用抖动采样 + TAA。
* 只在“相机地面投射范围”内渲染，半径随高度变化（俯视时范围更大，低空时更小）。

**过渡策略**

* 基于“云像素在屏幕上的覆盖尺寸”进行 LOD：

  * 小于 4px：仅 POM。
  * 4–20px：壳层加入，按覆盖率线性混合。
  * 大于 20px 或镜头距离云层 < 某阈值：启用局部体积。
* 过渡区用 0.1–0.2 的淡入宽度，避免跳变。

**阴影到地表**

* 近似：把高度/密度图低频高斯模糊（与太阳角度相关的各向异性模糊）生成一张**云影贴图**，投射到地表即可。
* 进阶：为**局部体积补丁**做一次沿太阳方向的积分出射，写入一张屏幕空间的“云影因子”，混到地表光照里（与本地雾/大气一致化）。

**纹理与坐标**

* 全球云图（光学厚度/覆盖度）建议分割成经纬度切片或等面积投影瓦片；两极区域在 POM/壳层阶段优先用 Triplanar。
* 近景体积使用相机对地的投影坐标（局部平面）或在球壳上做局部切空间投影，避免极点奇异。

**Three.js 实现要点**

* POM：`ShaderMaterial` 或 `NodeMaterial` 自定义片元；把 `viewDir` 变到切线空间，按上面的步进修正 UV。
* 壳层：`InstancedMesh(geomSphere, mat, N)`；在 VS 用 `gl_InstanceID` 沿 `normalize(position)` 偏移。`depthWrite=false`，`transparent=true`，注意渲染顺序。
* 近景体积：屏幕对齐四边形或一个贴地的局部四边形网格；FS 做球壳内的光线行进，输入地心、相机位、太阳方向。
* 抗闪烁：Three 自带 TAA 没有？可以用自定义后处理 pass（Jitter + Resolve），或把体积 pass 的结果作历史混合。

---

## 为什么不用“真几何位移”？

* 真几何（细分/微位移）才能改轮廓，但全球云层厚度只有几公里，放在 6000+ km 的半径上几乎不会改变球体轮廓；而且**运行时细分**在 WebGL 里不可得，WebGPU 自研门槛高。体渲染/POM/壳层更划算。

---

## 给你一套起步的数值（可直接套）

* 壳层：`N=24`，`H=0.004*R`（等价 \~25km 场景单位请按比例换算），`Δr=H/N`。
* POM：`steps=8 + 16*(1 - |N·V|)`，`heightScale=0.5*Δr`（按你的高度图动态调）。
* 体积：主步 12、光步 6；相机高度 < 2H 时启用，覆盖半径 `= clamp(200km, 0.3*cameraAlt, 800km)` 的地表投影区域。
* 阴影：云影半径依太阳高度角自适应模糊半径，低太阳角更长更软。

---

如果你愿意，我可以基于你现有的：

* 云覆盖/高度贴图的分辨率与投影（equirect/切片/瓦片），
* 目标平台（移动/桌面），
* 你的单位换算（地球半径在场景里是多少）
  直接给出三段式的最小 `ShaderMaterial` 模板（含 POM、壳层 VS/FS、体积 FS 的核心函数）和 LOD/过渡逻辑伪代码。
